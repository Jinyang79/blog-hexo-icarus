{"pages":[{"title":"个人简介","text":"微博 @瑾阳恰饱了饭说起从前 微信 17371438861 QQ 827126732 ❤️ 前端小白 ❤️ 欢迎大家 ❤️ 共同学习 如有侵权，请联系我哦","link":"/about/index.html"}],"posts":[{"title":"前端学习线路","text":"HTML5CSS3JavaScriptjquery ajaxnodevue小程序react","link":"/2019/12/27/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%BA%BF%E8%B7%AF/"},{"title":"前端常见跨域解决方案","text":"什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1231.) 资源跳转： A链接、重定向、表单提交2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： 1231.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送 常见跨域场景1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 一、 通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现： 12345678910111213&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); }&lt;/script&gt; 服务端返回如下（返回时即执行全局函数）： 1handleCallback({&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;}) 2.）jquery ajax： 1234567$.ajax({ url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: &quot;handleCallback&quot;, // 自定义回调函数名 data: {}}); 3.）vue.js： 123456this.$http.jsonp('http://www.domain2.com:8080/login', { params: {}, jsonp: 'handleCallback'}).then((res) =&gt; { console.log(res); }) 后端node.js代码示例： 1234567891011121314151617var querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) { var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();});server.listen('8080');console.log('Server is running at port 8080...'); jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt; 2.）子窗口：(http://child.domain.com/b.html) 12345&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + '#user=admin'; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert('data from c.html ---&gt; ' + res); }&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 123456789&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; };&lt;/script&gt; 3.）c.html：(http://www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); };&lt;/script&gt; 四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314151617181920212223242526272829303132333435var proxy = function(url, callback) { var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); }};// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data){ alert(data);}); 2.）proxy.html：(http://www.domain1.com/proxy….)中间代理页，与a.html同域，内容为空即可。 3.）b.html：(http://www.domain2.com/b.html) 123&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from domain2 ---&gt; ' + e.data); }, false);&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); } }, false);&lt;/script&gt; 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax 12// 前端设置是否带cookiexhr.withCredentials = true; 示例代码： 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); }}; 2.）jQuery ajax 12345678$.ajax({ ... xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...}); 3.）vue框架 a.) axios设置： 1axios.defaults.withCredentials = true b.) vue-resource设置： 1Vue.http.options.credentials = true 2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台： 12345678910111213/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Requested-With&quot;); 2.）Nodejs后台示例： 12345678910111213141516171819202122232425262728293031323334var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) { var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener('end', function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie }); res.write(JSON.stringify(postData)); res.end(); });});server.listen('8080');console.log('Server is running at port 8080...'); 七、 nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / { add_header Access-Control-Allow-Origin *;} 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： 123456789101112131415#proxy服务器server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; }} 1.) 前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 2.) Nodejs后台示例： 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) { var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, { 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 }); res.write(JSON.stringify(params)); res.end();});server.listen('8080');console.log('Server is running at port 8080...'); 八、 Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send(); 2.）中间件服务器： 123456789101112131415161718192021var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改}));app.listen(3000);console.log('Proxy server is listen at port 3000...'); 3.）Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置： 12345678910111213141516module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 }], noInfo: true }} 九、 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码： 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---&gt; ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); });});document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value);};&lt;/script&gt; 2.）Nodejs socket后台： 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) { res.writeHead(200, { 'Content-type': 'text/html' }); res.end();});server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); });}); 转载https://segmentfault.com/a/1190000011145364)","link":"/2019/12/20/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E5%85%A8%EF%BC%89/"},{"title":"学习日记","text":"11月30日第一次使用typora写日记 创建了个人网站 http://jinyang7.web3v.vip/ 网站简历素材学习 完善简历个人技能 项目经验没写 明天看jQuery 完善简历 12月1日完成的简历，投了宙源科技 准备最近可能的面试 装修个人网站 12月2日复习项目经历rem+flex vue 复习js 完成了music优化 12月3日vue学习p368 复习了axios 12月4日学习了 router webpack 复习了vue-cli脚手架创建 了解了vuex 12月5日vue学习视频p374完成了登录功能并上传码云 学习了git基本用法 电商后台管理系统完成home 的header vue视频p379 https://www.bilibili.com/video/av62487508复习原型 12月6日复习了原型 原型链 解析构造 完成了aside侧边栏菜单获取渲染数据p380 12月7日电商后台管理系统p386https://www.bilibili.com/video/av50680998?p=386 复习vue生命周期函数 完成侧边栏数据获取p390https://www.bilibili.com/video/av50680998?p=390 12月8日作用域插槽 123&lt;templata slot-scope=\"scope\"&gt; // scope.row 中包含当前行中的所有数据 {{scope.row}} 电商后台管理系统p399https://www.bilibili.com/video/av50680998?p=399 12月9日视频p409https://www.bilibili.com/video/av50680998?p=409 完成了添加用户，修改用户，表单验证，预验证 12月10日完成用户列表功能的开发（分支user 合并到master） 创建新分支rights（权限） 看到P430分配权限 做到p422 expand展开数据渲染 完成Right,Roles数据渲染 （重复的功能）Roles中添加角色，编辑，删除功能明天实现 12月11日上午完成了Roles的重复功能 完成展开数据渲染 样式没写 视频P434 整理学习视频https://pan.baidu.com/s/1YvqbO1mnnXzvALQRbdmTfw 12月12日完成了权限功能的开发p440 推送到rights分支，合并到master主分支 12月13日创建子分支goods_cate goods Cate.vue 使用了vue-table-with-tree-grid插件进行表格渲染 视频453 12月14日 管理后台系统BUG：点击编辑按钮 清空可以为空的数据（roles角色描述） 无法保存 ​ BUG: 重新获取数据（this.getCateList()）时，展开项会关闭 完成了分类功能的开发，推送到goods_cate分支，合并到master主分支 视频457 12月15日创建goods_params分支 了解计算属性computed 监听器watch P235 p468 获取的data 不需要分情况 tableData接收的数据 请求参数是动态 传过来的data就是动态数据 反之静态 P470 12月16日完成了分类参数的开发p485 推送到goods_params分支，合并到master主分支 12月17日GitHub创建Learning-diary.github.io vue-shop 同步到GitHub P505 12月18日 bug商品列表和商品分类编辑按钮无法预验证 商品列表编辑提交未实现 完成商品功能开发 推送到goods_list分支，合并到master主分支 视频521 12月19日了解vueP743https://www.bilibili.com/video/av74867960?p=746 P529完成订单功能的开发 推送到order分支，合并到master主分支 p535完成了报表功能的开发 推送到report分支，合并到master主分支 基本使用Echarts图表库 p536进入项目优化 12月20日p536项目优化 完成项目推送到云端 ！复习 p550项目上线 12月21日将桌面改成E盘E:\\Users\\Administrator\\Desktop 重新搭建node环境 将电商后台项目打包部署到个人网站http://jinyang7.web3v.vip/ bug打包的项目渲染有问题 12月22日解决了项目打包的项目渲染有问题：引入csn版本有问题 项目个人logo优化 通过hexo搭建个人博客 12月23日在腾讯云购买了域名goldsheep.club（1元/年）需要解析需要备案 48小时后 三丰云免费空间需要购买域名 放弃 使用liulongbing的后台api接口，完成电商后台项目 继续学习vuex https://www.bilibili.com/video/av74867960?p=757 视频757 创建并初始化vue_todos项目 12月24日搭建hexo博客，使用Icarus主题 上传文件 视频p764 todos项目完成了添加事项，删除事项，剩余条数 $hexo clean $hexo generate 12月25日了解vuepress搭建 完成todes项目推送到GitHub 管理后台系统BUG：修改商品接口有问题 Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。 12月26日学习Ajax https://www.bilibili.com/video/av75465709?p=23 P23 12月27日学习AjaxP50 学完学jQuery 12月28日优化icarus博客 Ajax jQuery todos等jQuery学完在看P52 jQueryP871开始947结束 P898https://www.bilibili.com/video/av74823132?p=898 12月29日优化icarus博客 jQuery P918 12月30日jQuery P940 明天用jQuery完成todolist项目 12月31日","link":"/2019/11/30/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"title":"学习笔记","text":"Git常见操作 git status 查看当前项目中源代码的状态 git add . 全部添加到暂存区 git commit -m &quot;提交信息&quot; 把暂存区所有代码提交到本地仓库中 git branch 查看分支 *当前处于分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换到分支 git merge 分支名 合并分支（合并到本地，云端并没有） git push 把本地分支中最新的代码推送到远程仓库中 默认master主分支 git push -u origin 分支名 第一次推送到此分支的时候使用 分支（login）合并到主分支（master） 1.切换到主分支 git checkout master 2.合并分支 git merge login 3.推送到云端（仓库）git push get和post请求区别 还有哪些http method get和post本质上没有区别，他们都是http的请求方式，基于tcp协议，但因为在不同的浏览器实现，就有了不同。 get请求的数据放在url上，post请求的数据放在http的包体内，所以说post相对get更安全。 get是通过URL提交数据，因此get提交数据根据url长度有关，不同的浏览器不同，一般是2k，而post理论上是没有限制的。 get幂等，post不幂等。 幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他请求方式（http method） head、put、delete、trace、connect、options vue的computed属性和methods区别最大的区别是缓存 计算属性是基于它们的依赖进行缓存的 方法不存在缓存 computed是响应式的，methods并非响应式。 调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。 computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的 初始化数据123456// 字符串string:'',// 数组array:[],// 数字number：0 vue过滤器p237 生命周期p239 render12345new Vue({ render: h =&gt; h(App)}).$mount('#app') render: h =&gt; h(App) 渲染到APP组件 $mount(‘#app’) 挂载到#app上 这是Vue 2.0新增的函数，可以直接给绑定节点渲染一个vue组件，如果在Vue 1.x下，就应该使用 1234new Vue({ el: '#app', components: { App }}); 然后在页面中写入标记： 123&lt;div id=&quot;app&quot;&gt; &lt;app&gt;&lt;/app&gt;&lt;/div&gt; 数组操作trim() 方法用于删除字符串的头尾空格。 trim() 方法不会改变原始字符串。 ES6，Array.find()和findIndex()函数的用法]ES6为Array增加了find()，findIndex函数。 find()函数用来查找目标元素，找到就返回该元素，找不到返回undefined。 findIndex()函数也是查找目标元素，找到就返回元素的位置，找不到就返回-1。 json**JSON.parse()** 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。 **JSON.stringify()** 方法将一个 JavaScript 值（对象或者数组）转换为一个 JSON 字符串。","link":"/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"常见前端面试题","text":"get和post请求区别 还有哪些http methodget和post本质上没有区别，他们都是http的请求方式，基于tcp协议，但因为在不同的浏览器实现，就有了不同。 get请求的数据放在url上，post请求的数据放在http的包体内，所以说post相对get更安全。 get是通过URL提交数据，因此get提交数据根据url长度有关，不同的浏览器不同，一般是2k，而post理论上是没有限制的。 get幂等，post不幂等。 幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他请求方式（http method） head、put、delete、trace、connect、options js数据类型undefined 未定义类型 null 空类型 boolean 布尔类型 number 数值型 string 字符串类型 symbol １种复杂数据类型：object —— 对象类型 csscalc, support, media各自的含义及用法？@support主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。 calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-“, “*”, “/“ 运算； @media 查询，你可以针对不同的媒体类型定义不同的样式。 css水平、垂直居中的写法，请至少写出4种？ 这题考查的是css的基础知识是否全面，所以平时一定要注意多积累 水平居中 行内元素: text-align: center 块级元素: margin: 0 auto position:absolute +left:50%+ transform:translateX(-50%) display:flex + justify-content: center 垂直居中 设置line-height 等于height position：absolute +top:50%+ transform:translateY(-50%) display:flex + align-items: center display:table+display:table-cell + vertical-align: middle; 1rem、1em、1vh、1px各自代表的含义？ rem rem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。 em 子元素字体大小的em是相对于父元素字体大小 元素的width/height/padding/margin用em的话是相对于该元素的font-size vw/vh 全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。 px px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 一般电脑的分辨率有{1920*1024}等不同的分辨率 1920*1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素 画一条0.5px的直线？ 考查的是css3的transform 12height: 1px;transform: scale(0.5); 说一下盒模型？ 盒模型是css中重要的基础知识，也是必考的基础知识 盒模型的组成，由里向外content,padding,border,margin. 在IE盒子模型中，width表示content+padding+border这三个部分的宽度 在标准的盒子模型中，width指content部分的宽度 box-sizing的使用 12box-sizing: content-box 是W3C盒子模型box-sizing: border-box 是IE盒子模型 box-sizing的默认属性是content-box 画一个三角形？ 这属于简单的css考查，平时在用组件库的同时，也别忘了原生的css 12345678910 .a{ width: 0; height: 0; border-width: 100px; border-style: solid; border-color: transparent #0099CC transparent transparent; transform: rotate(90deg); /*顺时针旋转90°*/ }&lt;div class=\"a\"&gt;&lt;/div&gt; 清除浮动的几种方式，及原理？ 清除浮动简单，但这题要引出的是BFC，BFC也是必考的基础知识点 ::after / / clear: both 创建父级 BFC(overflow:hidden) 父级设置高度 BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 触发条件: 根元素 position: absolute/fixed display: inline-block / table float 元素 ovevflow !== visible 规则: 属于同一个 BFC 的两个相邻 Box 垂直排列 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 文字层不会被浮动层覆盖，环绕于周围 html说一下标签的用法label标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验 遍历A节点的父节点下的所有子节点 这题考查原生的js操作dom,属于非常简单的基础题，但长时间使用mvvm框架，可能会忘记 1234&lt;script&gt; var b=document.getElementById(\"a\").parentNode.children; console.log(b)&lt;/script&gt; js用js递归的方式写1到100求和？ 递归我们经常用到，vue在实现双向绑定进行数据检验的时候用的也是递归，但要我们面试的时候手写一个递归，如果对递归的概念理解不透彻，可能还是会有一些问题。 123456789function add(num1,num2){ var num = num1+num2; if(num2+1&gt;100){ return num; }else{ return add(num,num2+1) } }var sum =add(1,2); 页面渲染html的过程？ 不需要死记硬背，理解整个过程即可 浏览器渲染页面的一般过程： 1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。 2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。 3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。 DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。 4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。 以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。 说一下CORS？CORS是一种新标准，支持同源通信，也支持跨域通信。fetch是实现CORS通信的 如何中断ajax请求？一种是设置超时时间让ajax自动断开，另一种是手动停止ajax请求，其核心是调用XML对象的abort方法，ajax.abort() 说一下事件代理？事件委托是指将事件绑定到目标元素的父元素上，利用冒泡机制触发该事件 123456ulEl.addEventListener('click', function(e){ var target = event.target || event.srcElement; if(!!target &amp;&amp; target.nodeName.toUpperCase() === \"LI\"){ console.log(target.innerHTML); }}, false); target、currentTarget的区别？currentTarget当前所绑定事件的元素 target当前被点击的元素 说一下宏任务和微任务？ 宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。 微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick等等）。 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。 说一下继承的几种方式及优缺点？ 说比较经典的几种继承方式并比较优缺点就可以了 借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上 原型继承，将子对象的prototype指向父对象的一个实例 组合继承 原型链继承的缺点 字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 说一下闭包？闭包的实质是因为函数嵌套而形成的作用域链 闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包 export和export default的区别？使用上的不同 12345export default xxximport xxx from './'export xxximport {xxx} from './' 说一下自己常用的es6的功能？ 此题是一道开放题，可以自由回答。但要注意像let这种简单的用法就别说了，说一些经常用到并有一定高度的新功能 像module、class、promise等，尽量讲的详细一点。 什么是会话cookie,什么是持久cookie?cookie是服务器返回的，指定了expire time（有效期）的是持久cookie,没有指定的是会话cookie 数组去重？ 此题看着简单，但要想面试官给你高分还是有难度的。至少也要写出几种方法 js 1234567891011121314151617181920212223242526272829303132333435var arr=['12','32','89','12','12','78','12','32']; // 最简单数组去重法 function unique1(array){ var n = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++){ //遍历当前数组 if (n.indexOf(array[i]) == -1) n.push(array[i]); } return n; } arr=unique1(arr); // 速度最快， 占空间最多（空间换时间） function unique2(array){ var n = {}, r = [], type; for (var i = 0; i &lt; array.length; i++) { type = typeof array[i]; if (!n[array[i]]) { n[array[i]] = [type]; r.push(array[i]); } else if (n[array[i]].indexOf(type) &lt; 0) { n[array[i]].push(type); r.push(array[i]); } } return r; } //数组下标判断法 function unique3(array){ var n = [array[0]]; //结果数组 for(var i = 1; i &lt; array.length; i++) { //从第二项开始遍历 if (array.indexOf(array[i]) == i) n.push(array[i]); } return n; } es6 123456es6方法数组去重arr=[...new Set(arr)];es6方法数组去重，第二种方法function dedupe(array) { return Array.from(new Set(array)); //Array.from()能把set结构转换为数组} get、post的区别 此题比较简单，但一定要回答的全面 1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内 2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制 3.get后退不会有影响，post后退会重新进行提交 4.get请求可以被缓存，post不可以被缓存 5.get请求只URL编码，post支持多种编码方式 6.get请求的记录会留在历史记录中，post请求不会留在历史记录 7.get只支持ASCII字符，post没有字符类型限制 你所知道的http的响应码及含义？ 此题有过开发经验的都知道几个，但还是那句话，一定要回答的详细且全面。 1xx(临时响应) 100: 请求者应当继续提出请求。 101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。 2xx(成功) 200：正确的请求返回正确的结果 201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。 202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。 3xx(已重定向) 300：请求成功，但结果有多种选择。 301：请求成功，但是资源被永久转移。 303：使用 GET 来访问新的地址来获取资源。 304：请求的资源并没有被修改过 4xx(请求错误) 400：请求出现错误，比如请求头不对等。 401：没有提供认证信息。请求的时候没有带上 Token 等。 402：为以后需要所保留的状态码。 403：请求的资源不允许访问。就是说没有权限。 404：请求的内容不存在。 5xx(服务器错误) 500：服务器错误。 501：请求还没有被实现。","link":"/2019/11/30/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"Icarus主题搭建技巧","text":"Icarus主题搭建技巧","link":"/2019/12/29/Icarus%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E6%8A%80%E5%B7%A7/"},{"title":"学习笔记","text":"Git操作解释 git status 查看当前项目中源代码的状态 git add . 全部添加到暂存区 git commit -m &quot;提交信息&quot; 把暂存区所有代码提交到本地仓库中 git branch 查看分支 *当前处于分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换到分支 git merge 分支名 合并分支（合并到本地，云端并没有） git push 把本地分支中最新的代码推送到远程仓库中 默认master主分支 git push -u origin 分支名 第一次推送到此分支的时候使用 Git常见操作 第一次提交代码至远程仓库 1.初始化git git init 2.提交全部文件git add . 3.提交到本地仓库 git commit -m “first commit” 4.关联远程仓库 git remote add origin 仓库地址 5.提交到远程仓库git push -u origin master 合并分支 1.切换到主分支 git checkout master 2.合并分支 git merge login 3.推送到云端（仓库）git push","link":"/2019/12/15/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"使用hexo搭建博客并上传Github","text":"使用hexo搭建博客并上传Github安装环境 安装git 安装node.js 运行cmd进行安装Hexo npm install -g hexo 使用git bash 创建hexo目录并初始化 $mkdir hexo $cd hexo $hexo init 然后就可以生成网站，启动服务了： $hexo clean $hexo generate $hexo server 在流浪器输入:http://localhost:4000/ _config.yml文件： deploy: type: git repository: https://github.com/WeDox/WeDoX.github.io.git branch: master $hexo clean $hexo generate $ npm install hexo-deployer-git –save （如果没有这句，执行下面的语句会出现:ERROR Deployer not found: git） $ hexo deploy //提交到github，输入https://wedox.github.io/即可 创建一篇新博客： $ hexo new “我是中国人” 然后到hexo\\source_posts\\我是中国人.md使用Markdown语言进行更新，如下 -– title: My Fist Post with hexo date: 2016-09-25 20:03:25 tags: -– 这是我的第一条博客 我是hexo的链接! ## 第一个标题 ### 我是子标题 $ hexo new “这一句的背景是一条黑线条” ## 我是第二个标题 More info: Writing 重新生成，然后提交到github $hexo clean $hexo generate $ hexo deploy 作者：jdallen链接：https://www.jianshu.com/p/40e7c10065c9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2019/12/28/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0Github/"}],"tags":[{"name":"http","slug":"http","link":"/tags/http/"},{"name":"学习日记","slug":"学习日记","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"前端面试题","slug":"前端面试题","link":"/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"}]}