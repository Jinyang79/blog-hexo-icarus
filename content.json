{"pages":[{"title":"Welcome to my blog ❤️","text":"🔹关于本站 🔷本站采用 hexo 博客框架，使用 Icarus 主题。 🔷追求简洁，方便阅读的风格，在 Icarus 主题之上进行了个性化的修改。 🔷建站初衷是为了当做个人笔记本📓，记录和整理技术知识点和踩过的坑，因个人技术栈方向，本站主要是以前端开发方向。 🔷博客内容编写除本人外，大部分是通过参考大佬们的博客进行总结整理，都是非常非常非常基础的知识，如果有错误，望各位大佬评论留言。 🔹关于我 🔷学历/专业：本科/软件工程 🔷身份：应届毕业生（实习中💦） 🔷技术栈：H5 / ES6 / Vue.js / React.js (PS:前端菜鸟🐤) 🔷兴趣：code💻 / 数码📱 / 纯音乐🎵 / 烧脑剧📺 / 网上冲浪🏄‍ 🔷最近喜欢的一句话：The trouble is, you think you have time.⌛ 🔹联系我 🔷在下方评论区留言 🔷Q Q ：827126732 🔷微信：yarn_start 🔷微博：@瑾阳恰饱了饭说起从前 🔷Email：jinyang79@foxmail.com 🔷GitHub：https://github.com/Jinyang79","link":"/about/index.html"}],"posts":[{"title":"Icarus主题搭建技巧","text":"文章页面两栏布局主题默认是三栏布局，并且显示了很多的 widget ，但在阅读文章时显得有些拥挤。因此在文章页面，修改为两栏布局，并显示特定的 widget。 1234567891011diff:includes/helpers/layout.jsconst widgets = hexo.extend.helper.get('get_config').bind(this)('widgets');- return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ if (this.page.layout !== 'post') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ }+ if (position === 'left') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; (widget.type === 'toc' || widget.type === 'profile'));+ } else {+ return []+ } 可以参考上述代码，即可实现不同页面不同 widget。 但两栏整体宽度跟三栏不同。因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 1234567891011121314151617diff:layout/common/widget.ejs &lt;% function side_column_class() { switch (column_count()) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3:diff:layout/layout.ejs-&lt;body class=\"is-&lt;%= column_count() %&gt;-column\"&gt;+&lt;body class=\"is-3-column\"&gt; &lt;%- partial('common/navbar', { page }) %&gt; &lt;% function main_column_class() { switch (column_count()) { case 1: return 'is-12'; case 2:- return 'is-8-tablet is-8-desktop is-8-widescreen';+ return 'is-8-tablet is-8-desktop is-9-widescreen'; 并修改在不同屏幕小大下的宽度 1234567891011121314diff:source/css/style.styl .is-2-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap+ .is-3-column .container+ max-width: screen-widescreen - gap+ width: screen-widescreen - gap @media screen and (min-width: screen-fullhd)+ .is-3-column .container+ max-width: screen-fullhd - 2 * gap+ width: screen-fullhd - 2 * gap .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap 目录粘性布局显示滚动条123diff:layout/widget/toc.ejs-&lt;div class=\"card widget\" id=\"toc\"&gt;+&lt;div class=\"card widget column-left is-sticky\" id=\"toc\" style=\"max-height: 680px; overflow: auto;\"&gt; 文章标题优化参考 https://www.alphalxy.com/2019/03/customize-icarus/#%E4%BC%98%E5%8C%96%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E5%B8%83%E5%B1%80 代码 https://github.com/ppoffice/hexo-theme-icarus/commit/6b3112b69b23f95539242d7a3ad2e48e3cc21ab2 可以配置文章开头是否显示图片Icarus 支持文章设置一个图片，在文章开头、最近的文章、时间线等地方显示。但有些图放大之后会显得很不协调，因此修改以支持自定义是否显示。修改 has_thumbnail 方法，增加参数 isArticle 参数，默认 false，并在文章页面修改调用参数。 1234567891011121314151617diff:includes/helpers/page.js- hexo.extend.helper.register('has_thumbnail', function (post) {+ hexo.extend.helper.register('has_thumbnail', function (post, isArticle = false) { const getConfig = hexo.extend.helper.get('get_config').bind(this); const allowThumbnail = getConfig('article.thumbnail', true); if (!allowThumbnail) { return false; }+ if (isArticle &amp;&amp; post['article-thumbnail'] === false){+ return false;+ } return post.hasOwnProperty('thumbnail') &amp;&amp; post.thumbnail;diff:layout/common/article.ejs &lt;div class=\"card\"&gt;- &lt;% if (has_thumbnail(post)) { %&gt;+ &lt;% if (has_thumbnail(post, true)) { %&gt; &lt;div class=\"card-image\"&gt; 这样修改之后，如果文章 meta 信息中包含 article-thumbnail: false，就可以取消图片的显示。","link":"/2019/12/01/Blog/Icarus%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E6%8A%80%E5%B7%A7/"},{"title":"使用hexo搭建博客并上传Github","text":"安装环境 安装git 安装node.js 运行cmd进行安装Hexo npm install -g hexo 使用git bash 创建hexo目录并初始化 $mkdir hexo $cd hexo $hexo init 然后就可以生成网站，启动服务了： $hexo clean $hexo generate $hexo server 在流浪器输入:http://localhost:4000/ _config.yml文件： deploy: type: git repository: https://github.com/WeDox/WeDoX.github.io.git branch: master $hexo clean $hexo generate $ npm install hexo-deployer-git –save （如果没有这句，执行下面的语句会出现:ERROR Deployer not found: git） $ hexo deploy //提交到github，输入https://wedox.github.io/即可 创建一篇新博客： $ hexo new “我是中国人” 然后到hexo\\source_posts\\我是中国人.md使用Markdown语言进行更新，如下 -– title: My Fist Post with hexo date: 2016-09-25 20:03:25 tags: -– 这是我的第一条博客 我是hexo的链接! ## 第一个标题 ### 我是子标题 $ hexo new “这一句的背景是一条黑线条” ## 我是第二个标题 More info: Writing 重新生成，然后提交到github $hexo clean $hexo generate $ hexo deploy 作者：jdallen链接：https://www.jianshu.com/p/40e7c10065c9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2019/12/27/Blog/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0Github/"},{"title":"Icarus修改日记","text":"2月27日添加 最新文章缩略图 thumbnail: 图片url 隐藏文章图片 article-thumbnail: false/true 推荐链接标签 links 2月29日修改文章h1~6字体 加粗 boldthemes\\icarus\\source\\css\\style.styl .content font-weight: bold修改文章字体内容themes\\icarus\\source\\css\\style.styl .article font-weight: bold !important","link":"/2019/11/30/Blog/Icarus%E4%BF%AE%E6%94%B9%E6%97%A5%E8%AE%B0/"},{"title":"CSS常见布局","text":"左边固定右边自适应布局","link":"/2020/01/27/CSS/CSS%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/"},{"title":"清除浮动","text":"清除浮动可以理解为清除浮动产生的影响。当元素浮动时也就是为当前元素创建了块格式化上下文（BFC），会对周围的元素或者父元素在布局上会产生一定的影响。 比如：父元素因无法自动计算高度而产生的高度塌陷；因脱离文档流而使兄弟元素错位等。 要清除浮动产生的影响，其实就是在解决这两方面的问题。方法是可以通过设置父元素高度，或利用BFC，或者使用自带属性 clear进行清除。 1. 设置父元素的高度设置父元素的高度解决的是元素浮动产生的父元素高度塌陷问题，其内部元素浮动影响并未彻底清除，且需要进行计算然后再设置，比较固定，一旦子元素的高度发生改变，父元素的高度也需要再次计算设置，不够灵活。除非内容高度固定一成不变，否则不推荐使用。 2. 利用BFC根据BFC的规则计算BFC的高度时，浮动元素也参与计算, 父级元素设置为overflow : hidden该方法是需要把属性添加到父元素当中，以解决内部元素浮动影响。不能用于解决兄弟元素的浮动问题。 3. 自带属性 clear使用自带的属性可以非常好的解决浮动影响。该方法直观有效，哪里需要清除就在哪里添加一个兄弟元素，设置 clear 属性即可，一般属性值都设置为 both 清除两侧的浮动，也可以根据实际需要清除左侧或右侧，灵活方便直观。在 bootstrap 4.0 框架中的 clearfix 应用了该方法，其是在父元素中设置了伪元素，并设置了伪元素隐藏。 伪类元素（::after,::before） 12345.clearfix::after { content: ''; display: block; clear: both;} 推荐使用添加伪元素的方法","link":"/2020/02/24/CSS/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"title":"BFC","text":"什么是BFC块格式化上下文(Block Formatting Context，BFC)是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 你可以把它理解成一个独立的区域 BFC的作用BFC形成一个完全独立的空间,让空间的子元素不会影响到外面的布局 BFC 的原理/BFC的布局规则BFC 的原理，其实也就是 BFC 的渲染规则。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。 BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。 计算BFC的高度时，浮动的子元素也参与计算。 常用触发条件 float不为none position不为relative，static overflow为auto scroll，hidden display为table-cell，inline-block，flex BFC 的应用1.浮动元素的父元素高度塌陷问题 子元素全是float元素且父元素没有设置高度. 浮动的子元素脱离文档流,父元素检测不到子元素的存在无法被撑开,导致父元素高度塌陷,后面布局出现混乱 解决方案 清除浮动 2.两栏自适应布局问题 在通过浮动实现两栏自适应布局时(左边宽度固定,右边自适应),当右侧文字高度超出左侧高度时,会出现右侧文字出现在左侧的问题 解决方案 右侧的元素创建BFC，将right区域添加overflow属性 3.外边距垂直方向重合问题 当两个块级元素分别设置margin-bottom:20px,margin-top:25px=&gt;此时实际两个块级边框距离为最大值(25px) 解决方案 1.其中一个p元素外面包裹一层父元素，触发父元素BFC比如 overflow: hidden 2.用padding代替margin 参考文章：https://github.com/poetries/FE-Interview-Questions","link":"/2020/02/24/CSS/BFC/"},{"title":"Promise(常用方法)","text":"参考原文 http://es6.ruanyifeng.com/#docs/promise Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 从语法上讲，Promise是一个对象，从它可以获取异步操作的信息 主要好处： 可以避免多层异步通用嵌套问题（回调地狱）。 Promise对象提供了简洁的API，使得控制异步操作更加容易。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error);js }}); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) { // success}, function(error) { // failure}); then方法可以接受两个回调函数作为参数。 第一个回调函数是Promise对象的状态变为resolved时调用， 第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 在原生JS中发送Ajax的用法12345678910111213141516171819 function getJSON(url) { return new Promise(function (resolve, reject) { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { resolve(xhr.responseText); } else { reject('服务器错误') } }; xhr.open('get', url); xhr.send(); });}getJSON(\"/posts.json\").then( json =&gt; console.log('Contents: ' + json), error =&gt; console.error('出错了', error)); 在jQuery中发送Ajax的用法12345678910function getJSON(url){ return $.ajax({ url: \"url\", dataType: \"json\", })}getJSON().then( json =&gt; console.log('Contents: ' +json), error =&gt; console.error('出错了', error)); 实例方法Promise.prototype.then()得到异步任务的结果 12345promise.then(function(value) { // resolved状态}, function(error) { // rejected状态}); 它的作用是为 Promise 实例添加状态改变时的回调函数。 then方法的参数 ：（都是函数） 第一个参数是resolved状态的回调函数 第二个参数（可选）是rejected状态的回调函数。 then方法的返回值 返回promise实例对象 返回的实例对象会调用下一个then 1234567getJSON(\"/post/1.json\").then(function(post) { return getJSON(post.commentURL);}).then(function (comments) { console.log(\"resolved: \", comments);}, function (err){ console.log(\"rejected: \", err);}); 返回普通值 返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收。 实际上返回的还是Promise实例（默认的），因此可以通过.then方法调用。 12345getJSON(\"/posts.json\").then(function(json) { return 'hello'; // 返回字符串}).then(function(post) { console.log(post) // hello}); Promise.prototype.catch()获取错误的信息 Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) { // ...}).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);}); Promise.prototype.finally()成功与否都会执行 finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result =&gt; {···}).catch(error =&gt; {···}).finally(() =&gt; {···}); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 对象方法Promise.all()并发处理多个异步任务，所有任务都执行完成才能得到结果 123456var p1 = getJSON('url1');var p2 = getJSON('url2');var p3 = getJSON('url3');Promise.all([p1, p2, p3]).then(function (json) { console.log(json) // 按照顺序返回得到的结果}) Promise的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.race()并发处理多个异步任务，只要有一个任务完成就能得到结果 123Promise.race([p1, p2, p3]).then(function (json) { console.log(json) // 返回第一个得到的结果}) Promise的状态由p1、p2、p3决定 如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。","link":"/2020/01/14/ES6+/promise/"},{"title":"async","text":"anync关键字 普通函数定义前加async关键字普通函数变成异步函数 异步函数默认返回promise对象 在异步函数内部使用return关键字进行结果返回结果会被包裹的promise对象中return关键字代替 了resolve方法 在异步函数内部使用throw关键字抛出程序异常 调用异步函数再链式调用then方法获取异步函数执行结果 调用异步函数再链式调用catch方法获取异步函数执行的错误信息 async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。 await关键字 await关键字只能出现在异步函数中 await promise await后面只能写promise对象其他类型的API是不不可以的 await关键字可是暂停异步函数向下执行直到promise返回结果 await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function。 若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。 另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。 示例node 依次读取文件内容 123456789101112// es5const fs = require('fs');fs.readFile('./1.txt', 'utf8', (err, result1) =&gt; { console.log(result1); fs.readFile('./2.txt', 'utf8', (err, result1) =&gt; { console.log(result1); fs.readFile('./3.txt', 'utf8', (err, result1) =&gt; { console.log(result1); }) })}); 123456789101112131415161718192021222324252627282930313233343536// es6 promiseconst fs = require('fs');function p1 () { return new Promise((resolve, reject) =&gt; { fs.readFile('./1.txt', 'utf8', (err, result) =&gt; { resolve(result) }) })}function p2 () { return new Promise((resolve, reject) =&gt; { fs.readFile('./2.txt', 'utf8', (err, result) =&gt; { resolve(result) }) })}function p3 () { return new Promise((resolve, reject) =&gt; { fs.readFile('./3.txt', 'utf8', (err, result) =&gt; { resolve(result) }) })}p1().then((r1) =&gt; { console.log(r1); return p2()}) .then((r2) =&gt; { console.log(r2); return p3() }) .then((r3) =&gt; { console.log(r3); }) 12345678910111213141516// es7 async awaitconst fs = require('fs');// 改造现有异步函数api 让其返回promise对象 从而支持异步函数语法const promisify = require('util').promisify;// 调用promisify方法改造现有异步api 让其返回promise对象const readFile = promisify(fs.readFile);async function run () { let r1 = await readFile('./1.txt', 'utf8') let r2 = await readFile('./2.txt', 'utf8') let r3 = await readFile('./3.txt', 'utf8') console.log(r1); console.log(r2); console.log(r3);}run();","link":"/2020/03/17/ES6+/anync/"},{"title":"Proxy及其优势","text":"什么是 Proxy ？ Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 语法ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1const proxy = new Proxy(target, handler) Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。 其中： new Proxy()表示生成一个Proxy实例。 target参数表示所要拦截的目标对象。 handler参数也是一个对象，用来定制拦截行为方法。 同一个拦截器函数，可以设置拦截多个操作。 下面是一个拦截读取属性行为的例子。 123456789const proxy = new Proxy({}, { get: function(target, propKey) { return 35; }});proxy.time // 35proxy.name // 35proxy.title // 35 handler 对象的方法(拦截方法）详细介绍见阮一峰老师的ES6入门或MDN 下面是 Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 Proxy 与 Object.defineProperty 优劣对比分析 Object.definedProperty 的作用是劫持一个对象的属性，劫持属性的getter和setter方法，在对象的属性发生变化时进行特定的操作。而 Proxy 劫持的是整个对象。 Proxy 会返回一个代理对象，我们只需要操作新对象即可，而 Object.defineProperty 只能遍历对象属性直接修改。 Object.definedProperty 不支持数组，更准确的说是不支持数组的各种API，因为如果仅仅考虑arry[i] = value 这种情况，是可以劫持的，但是这种劫持意义不大。而 Proxy 可以支持数组的各种API。 尽管 Object.defineProperty 有诸多缺陷，但是其兼容性要好于 Proxy. PS: Vue2.x 使用 Object.defineProperty 实现数据双向绑定，V3.0 则使用了 Proxy. 结论Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 参考文章： ECMAScript 6 入门教程 MDN-Proxy Proxy 与 Object.defineProperty 优劣对比 实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?","link":"/2020/04/10/ES6+/proxy/"},{"title":"SCSS入门","text":"简介SCSS（Sassy CSS ）是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。 Sass 和 SCSS 是同一种CSS预处理器，都称之为 Sass，两者之间不同之处有以下两点： 文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名。 语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。 所以推荐使用SCSS。 Sass语法： 12345// .sass$primary-color: red.header background-color: $primary-color SCSS语法： 123456// .scss$primary-color: red;.header { background-color: $primary-color; } 用法变量123456789$primary-color: red; // 定义变量$primary-border: 1px solid $primary-color;.header { background-color: $primary-color; } .nav { border: $primary-border;} 嵌套123456789.nav { height: 100px; ul{ margin: 0; li{ padding: 5px; } }} 嵌套调用父选择器&amp; 常使用伪类选择器 123456li { padding: 5px; &amp;:hover { color: #fff; } } 嵌套属性scss 123456li { border:1px solid #aaa { left: 0; right: 0; }} css 123456li { border:1px solid #aaa ; border-left: 0; border-right: 0; } 混合-mixin@mixin声明函数 @include使用函数 scss 123456789@mixin alert { color: red; a{ color: blue; }}.alert-warning { @include alert;} css 123456.alert-warning { color: red;}.alert-warning a { color: blue;} mixin的参数123456789@mixin alert($text-color,$bg-color) { background-color: $bg-color; a{ color: $text-color; }}.alert-warning { @include alert(red,blue);} 继承-extend@extend继承 123456789.alert { color: red;}.alert a{ font-size: 10px;}.alert-warning { @extend .alert;} 导入-import@import1@import \"foo\"; 分音 (Partials)如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。 例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。 1@import \"colors\"; 上面的例子，导入的其实是 _colors.scss 文件 参考文章：https://www.sass.hk/docs/","link":"/2020/02/16/CSS/SCSS%E5%85%A5%E9%97%A8/"},{"title":"Git上传失败问题","text":"git推送失败git push -u origin master 错误提示 123456789$ git push -u origin masterUsername for 'https://github.com': xxxTo https://github.com/xxx.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'https://github.com/xxx.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 错误分析GitHub远程仓库中的README.md文件不在本地仓库中。 解决方案1强制推送命令 1git push -f origin master 解决方案2代码合并 12git pull --rebase origin mastergit push origin master git提交失败 git:&gt;running pre-commit hook:lint-staged 错误分析这句话的意思，大概是有一个钩子，提交前检查项目代码的规范，eslint的检查。提交失败的原因：项目中error过多，导致检测未通过，提交失败。 解决方案一、不进行检查 那就是删除掉pre-commit hook，具体在项目文件夹.git\\hooks目录下，找到文件pre-commit ​ 二、再次提交成功 这个方法比较简单粗暴，自然也是存在一些弊端，代码不严谨，不能符合Eslint标准。也有其他的解决方式，在配置文件中，不需要使用eslint时，把lintOnSave设为false即可。","link":"/2020/02/10/Git/Git%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"title":"URL到网页过程","text":"从输入URL到显示网页的步骤 DNS 解析:将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手 DNS 解析:将域名解析成 IP 地址TCP 连接：TCP 三次握手发送 HTTP 请求服务器处理请求并返回 HTTP 报文http报文 浏览器解析渲染页面 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 将渲染树每个节点绘制到屏幕。 断开连接：TCP 四次挥手","link":"/2020/03/16/HTTPS/URL%E5%88%B0%E7%BD%91%E9%A1%B5%E8%BF%87%E7%A8%8B/"},{"title":"HTTPS协议","text":"HTTP 存在的问题 HTTP 报文使用明文方式发送，可能被第三方窃听。 HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。 HTTP 还存在认证的问题，第三方可以冒充他人参与通信。 什么是 HTTPSHTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。 TLS（Transport Layer Security，安全传输层协议） SSL(Secure Sockets Layer 安全套接层) HTTP 与 HTTPS 的区别 HTTP 是明文传输，HTTPS 通过 TLS/ SSL 进行了加密传输。 HTTP 的端口号是 80，HTTPS 是 443。 HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费。 HTTP的连接很简单，是无状态的；HTTPS 协议是由 TLS/ SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。 HTTPS 原理一个简化的（例如下图没有包含Pre-Master Secret）https流程图如下 TLS 握手过程 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥 来加密信息。 详细实现原理TLS 的握手过程主要用到了三个方法来保证传输的安全。 首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。 因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存 在的问题。 但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。 为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。 参考文章： 一个故事讲完https 谈谈 HTTPS","link":"/2020/04/11/HTTPS/HTTPS%E5%8D%8F%E8%AE%AE/"},{"title":"JS模块化","text":"为什么要使用模块化？无模块化的痛点 命名冲突 文件依赖（js 加载顺序） 代码复用 模块化带来的好处 解决命名冲突 提供复用性 提高代码可维护性 通常，我们在浏览器中使用 ES6 的模块化支持，在 Node,webpack 中使用 commonjs 的模块化支持。 具体实现方式及特点AMDrequire / defined 适用于浏览器端 异步模块加载 是requirejs 在推广过程中对模块定义的规范化产出 对于依赖的模块提前执行，推崇依赖前置 CMD与AMD很类似 适用于浏览器端 异步模块加载 是seajs 在推广过程中对模块定义的规范化产出， 对于依赖的模块延迟执行，推崇依赖就近 CommonJsrequire / module.exports / exports 适用于服务器端 同步的方式加载模块 模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成 ES6 Moduleimport / export 适用于浏览器和服务器端 模块输出的是一个值的引用，编译时输出接口，ES6模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。 异同点AMD和CMDAMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。 AMD和CommonJs CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 ES6 Module与CommonJSES6 Module和CommonJS模块的异同点： CommonJS模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const CommonJS加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口； CommonJS中的this指向当前模块，ES6 Module中的 this指向undefined; ES6 Module和CommonJS模块的共同点： CommonJS和ES6 Module都可以对引入的对象内部属性的值进行改变。 目前浏览器对ES6 Module兼容还不太好，我们平时在webpack中使用的export/import，会经过babel转换为CommonJS规范。 参考链接 再次梳理AMD、CMD、CommonJS、ES6 Module的区别 前端模块化：CommonJS,AMD,CMD,ES6 ES6 模块与 CommonJS 模块的差异","link":"/2020/03/03/JS/JS%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"Git版本回退","text":"(参考廖雪峰的Git教程) (已经git add file 并且 git commit -m 提交信息 但没推送云端 想回到上个版本或其他版本) 回退版本 ❗git reset --hard 版本号/HEAD^ ：命令回退到指定的版本号/上一次 ❗ 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位 ❗ 用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 查看提交历史版本号信息git log ：命令显示从最近到最远的提交日志 123456$ git logcommit commit id（版本号） (HEAD -&gt; master)Author: 提交作者Date: 提交时间 提交的内容 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数 1234$ git log --pretty=onelinecommit id（上次版本号） (HEAD -&gt; master) 上次提交的内容commit id（上上次版本号） 上上次提交的内容commit id（上上上次版本号） 上上上次提交的内容 坑❗ 输入q退出查看记录 后悔药💊在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到上个版本时，再想恢复原来，就必须找到原来的commit id（版本号）。Git提供了一个命令git reflog用来记录你的每一次命令： 123$ git refloge475afc HEAD@{1}: reset: moving to HEAD^版本号 (HEAD -&gt; master) HEAD@{2}: commit: 提交信息 ❗ 输入q退出查看记录 然后可以通过git reset --hard 版本号 恢复啦😁","link":"/2020/01/05/Git/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"},{"title":"JS中的this指向","text":"❗以下this指向均在非严格模式下，在严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined。 函数this指向 this指向函数运行时所在的对象，而不是函数被创建时所在的对象。 匿名函数或者简单调用的函数来说，this指向window，剩下的函数调用，指向调用者。 如果有new关键字，this指向new出来的那个对象。 可以通过apply，call，bind改变this的指向。 箭头函数没有this，指向取决于该箭头函数声明的位置，在哪里声明，this就指向哪里。 箭头函数中的this 箭头函数的this指向，是定义时所在的对象，而不是使用时所在的对象。 12345678910111213// 普通函数let obj = { a: function () { console.log(this) }}obj.a(); // obj// 箭头函数let obj = { a: () =&gt; console.log(this)}obj.a(); // Window 箭头函数是没有 this **的，函数中的 this 指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象**） 123456// 外层函数是普通函数let obj = {}function a() { return () =&gt; console.log(this);}a.call(obj)();// obj 普通函数中的this指向是可变的，但是在箭头函数中，它是固定的，无法改变。 1234567891011// 普通函数let obj = {};let a = function () { console.log(this);}a.call(obj); // obj// 箭头函数let obj = {};let a = () =&gt; console.log(this);a.call(obj) // Window","link":"/2020/01/10/JS/%E6%80%BB%E7%BB%93JS%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/"},{"title":"JavaScript闭包（Closure）","text":"123456789function f1(){ var n=999; function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999 上面代码产生了闭包 闭包的概念下面是一些官方的概念函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript，函数在每次创建时生成闭包。 闭包（closure）是指有权访问另一个函数作用域中变量的函数 闭包是指拥有多个变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 但不要咬文嚼字，我们简单的可以理解为 闭包是个函数，而它「记住了周围发生了什么」。表现为由「一个函数」体中定义了「另个函数」 通俗的理解闭包 就是 能够读取 其他函数 内部(局部)变量 的函数。 上面代码中 f2 可以访问 f1 的 n变量 也就是局部变量，于是产生了闭包，f2就是闭包函数 闭包的作用主要作用：延申了变量的作用范围它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。（等所有的函数调用完了 才会销毁） 使用闭包的注意点 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 闭包经典案例代码片段二。 123456789101112131415var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()()); //The Window 代码片段二。 12345678910111213141516 var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ var that = this; return function(){ return that.name; }; } }; alert(object.getNameFunc()()); //My Object https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html","link":"/2020/01/11/JS/JavaScript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/"},{"title":"赋值、浅拷贝、深拷贝关系以及实现","text":"在探讨这个问题之前，首先得了解ECMAScript 的数据类型 ECMAScript 的数据类型 其次是堆和栈的区别 堆和栈的区别其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。 堆和栈都是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放。 堆（heap）内存是动态分配的内存，大小不定也不会自动释放。一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。 基本（原始）数据类型（Undefined、Null、Boolean、Number、String）的值直接保存在栈中 引用（复杂）数据类型（对象、数组和函数）的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。 对原数据影响 – 和原数据是否指向同一对象 第一层数据为基本数据类型 原数据中包含子对象 赋值 是 改变会使原数据一同改变 改变会使原数据一同改变 浅拷贝 否 改变不会使原数据一同改变 改变会使原数据一同改变 深拷贝 否 改变不会使原数据一同改变 改变不会使原数据一同改变 总结浅拷贝浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。所以说，浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。 深拷贝深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。 实现方式浅拷贝1.Object.assign(target, ...sources)123456let a = { age: 1}let b = Object.assign({}, a)a.age = 2console.log(b.age) // 1 2.扩展运算符 ...123456let a = { age: 1}let b = { ...a }a.age = 2console.log(b.age) // 1 3.遍历+hasOwnProperty()123456789101112131415161718// 浅拷贝的实现;function shallowCopy(object) { // 只拷贝对象 if (!object || typeof object !== \"object\") return; // 根据 object 的类型判断是新建一个数组还是对象 let newObject = Array.isArray(object) ? [] : {}; // 遍历 object，并且判断是 object 的属性才拷贝 for (let key in object) { if (object.hasOwnProperty(key)) { newObject[key] = object[key]; } } return newObject;} 深拷贝1.JSON.parse(JSON.stringify(object))123456789let a = { age: 1, jobs: { first: 'FE' }}let b = JSON.parse(JSON.stringify(a))a.jobs.first = 'native'console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 2.递归+hasOwnProperty()12345678910111213141516// 深拷贝的实现;function deepCopy(object) { if (!object || typeof object !== \"object\") return; let newObject = Array.isArray(object) ? [] : {}; for (let key in object) { if (object.hasOwnProperty(key)) {js newObject[key] = typeof object[key] === \"object\" ? deepCopy(object[key]) : object[key]; } } return newObject;} 参考文章 js 深拷贝 vs 浅拷贝 js 中的深浅拷贝实现","link":"/2020/04/01/JS/%E8%B5%8B%E5%80%BC%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%85%B3%E7%B3%BB/"},{"title":"观察者模式和发布订阅模式有什么不同？","text":"观察者模式和发布订阅模式有什么不同？发布订阅模式其实属于广义上的观察者模式 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。 而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。 观察者模式 vs 发布-订阅模式","link":"/2020/03/22/JS/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"},{"title":"Vuex","text":"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应 的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了 诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 作用 状态管理（非父子通信） 状态快照（数据缓存） 方便管理和调试，时光旅行 statestate:单一状态树 ,每个应用将仅仅包含一个 store 实例。 *this.$store.state.状态名字 *…mapState([“title”]) gettersgetters:可以从store 中的 state 中派生出一些状态，getters的返回值会根据 它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 *可以认为是 store 的计算属性 *this.$store.getters.计算属性名字 *…mapGetters([“getFilms”]) mutationsmutations：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 *常量的设计风格 [SOME_MUTATION] (state) { // mutate state } *必须是同步函数 *this.$store.commit(“type”,”payload”); actionsactions: *Action 提交的是 mutation，而不是直接变更状态。 *Action 可以包含任意异步操作。 *this.$store.dispatch(“type”,”payload”) 注意: 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面","link":"/2020/01/21/Vue.js/vuex/"},{"title":"npm常用命令","text":"查看npm命令： 1$ npm help 始化一个基于node的项目，会创建一个配置文件package.json（两种方式）: 12345//1.一般情况下 一路enter$ npm init//2.全部使用默认配置$ npm init --yes 安装模块（包）： 1234567891011//全局安装$ npm install 模块名 -g//本地安装$ npm install 模块名//一次性安装多个$ npm install 模块1 模块2 模块n --save//安装运行时依赖包$ npm install 模块名 --save//安装开发时依赖包$ npm install 模块名 --save-dev 查看安装目录： 12345//查看本地安装的目录$ npm root//查看全局安装的目录$ npm root -g 卸载模块（包）： 12345//卸载本地模块$ npm uninstall 模块名//卸载全局模块$ npm uninstall -g 模块名 更新模块（包） 123$ npm update 模块名$ npm update 模块名 -g 查看当前安装的模块（包） 123$ npm ls$ npm ls -g 查看模块（包）的信息： 1$ npm info 模块名 在使用 npm install 命令时，有许多指定参数的命令是可以进行缩写的，本文就简单梳理一下。 npm install本身有一个别名，即npm i，可以使用这种缩写方式来运行命令，打到简化的效果。 以下为指定的一些命令行参数的缩写方式： -g –global，缩写为-g，表示安装包时，视作全局的包。安装之后的包将位于系统预设的目录之下，一般来说 -S –save，缩写为-S，表示安装的包将写入package.json里面的dependencies。 表示我们要在生产环境下使用该依赖。 -D –save-dev，缩写为-D，表示将安装的包将写入packege.json里面的devDependencies。则表示我们仅在开发环境使用该依赖。 -O –save-optional缩写为-O，表示将安装的包将写入packege.json里面的optionalDependencies。 -E –save-exact缩写为-E，表示安装的包的版本是精确指定的。 -B –save-bundle缩写为-B，表示将安装的包将写入packege.json里面的bundleDependencies。","link":"/2020/03/02/Node.js/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"跨域解决方案","text":"跨域（非同源策略请求） 因为浏览器出于安全考虑，有同源策略。同源策略是指协议、域名、端口，三者都相同。 也就是说，如果协议、域名、端口，只要有一个不同就是跨域， 请求就会失败。 常用跨域解决方案jsonp跨域原理 JSONP 的原理很简单，就是利用&lt;script&gt; 标签没有跨域限制的漏洞。通过&lt;script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据。 原生实现jsonp 123456&lt;script&gt; function callback(res) { console.log(res); }&lt;/script&gt;&lt;script src=\"http://localhost:3030/server?callback=callback\"&gt;&lt;/script&gt; jQuery中Ajax实现jsonp 123456$.ajax({ url: 'http://localhost:3030/server', type: 'get', // 可以省略 dataType: 'jsonp', // 请求方式为jsonp success: res =&gt; console.log(res)}); server.js 12345678910const express = require('express')const app = express()app.get('/server', function (req, res) { const { callback } = req.query const data = { message: '请求成功' } res.send(`${callback}(${JSON.stringify(data)})`)})app.listen(3030) jsonp只支持GET请求 cors（跨域资源共享）CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求只要同时满足以下两大条件，就属于简单请求 条件1：使用下列方法之一： GET HEAD POST 条件2：Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 复杂请求不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段 前端设置 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) { console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) } }}xhr.send() 后端设置 12345//server1.jslet express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) { let origin = req.headers.origin if (whitList.includes(origin)) { // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') { res.end() // OPTIONS请求不做任何处理 } } next()})app.put('/getData', function(req, res) { console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('请求成功')})app.get('/getData', function(req, res) { console.log(req.headers) res.end('请求成功')})app.use(express.static(__dirname))app.listen(4000) 上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。 nodejs中间件代理跨域（http proxy）node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send(); 中间件服务器： 123456789101112131415161718192021var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改}));app.listen(3000);console.log('Proxy server is listen at port 3000...'); Nodejs后台同nginx vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置： 12345678910111213141516module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 }], noInfo: true }} nginx反向代理实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 先下载nginx，然后将nginx目录下的nginx.conf修改如下: 123456789101112131415// proxy服务器server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; }}复制代码 最后通过命令行nginx -s reload启动nginx 1234567// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 123456789101112131415// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) { var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, { 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 }); res.write(JSON.stringify(params)); res.end();});server.listen('8080');console.log('Server is running at port 8080...'); 以下方案了解为主（具体实现参考结尾链接）postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 otherWindow.postMessage(message, targetOrigin, [transfer]); message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 WebSocket协议跨域Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain ='test.com' 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 location.hash + iframe跨域实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 使用总结CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案 JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。 在 dev 开发模式下可以下使用 webpack 的 proxy 使用也是很方便，参照 文档 就会使用了，但这种方法在生产环境是不能使用的。在生产环境中需要使用 nginx 进行反向代理。不管是 proxy 和 nginx 的原理都是一样的，通过搭建一个中转服务器来转发请求规避跨域的问题。 开发环境 生产环境 cors cors proxy nginx 参考文章： 九种跨域方式实现原理（完整版） 前端常见跨域解决方案（全） 跨域资源共享 CORS 详解","link":"/2020/02/27/JS/%E8%B7%A8%E5%9F%9F/"},{"title":"vue时间戳转化","text":"函数封装 1234567891011121314// dateFilter.jsexport function dateFilter (timestamp) { function zero (time) { return time &lt; 10 ? '0' + time : time } var date = new Date(Number(timestamp) * 1000)// 时间戳为10位需*1000，时间戳为13位的话不需乘1000 let Y = date.getFullYear() + '-' let M = (date.getMonth() + 1 &lt; 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-' let D = zero(date.getDate()) + ' ' let h = zero(date.getHours()) + ':' let m = zero(date.getMinutes()) + ':' let s = zero(date.getSeconds()) return Y + M + D + h + m + s}; 引入注册全局组件123456// main.jsimport Vue from 'vue'// 引入时间戳过滤器import { dateFilter } from './filter/datefilter'// 注册为全局过滤器Vue.filter('dateFilter', dateFilter) 使用123&lt;template&gt; &lt;div class=\"time\"&gt;{{ data.time | dateFilter }}&lt;/div&gt;&lt;/template&gt;","link":"/2020/02/08/Vue.js/vue%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96/"},{"title":"Vue Router","text":"参考 vue官网 https://juejin.im/post/5b0281b851882542845257e7 简介Vue Router 是 Vue.js 官方的路由管理器。也就是SPA（单页应用）的路径管理器。 vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。 路由模块的本质就是建立起url和页面之间的映射关系。实质上就是路劲的切换，也就是组件之间的切换。 传统的页面应用，是用一些超链接来实现页面切换和跳转的。 至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（当你的项目准备打包 时，运行npm run build 时，就会生成dist文件夹，这里面只有静态资源和一个 index.html页面），所以你写的标签是不起作用的， 你必须使用vue-router来进行管理。 实现原理SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面， 而是只更新某个指定的容器中内容。 单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面; vue-router在实现单页面前端路由时，提供了两种方 式：Hash模式和History模式。 根据mode参数来决定采用哪一种方式。 12345// 在 router/index.js 文件中const router = new VueRouter({ mode: 'history', // 默认是 hash routes}) 1.Hash模式vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重 新加载。 例如 http://yoursite.com/user/#/id hash 模式的原理是 onhashchange 事件(监测hash值变化)，可以在 window 对象上监听这个事件。 2.HTML5 History 模式如果不想要很丑的 hash（路径有 #），我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，也好看！不过这种模式 要玩好，还需要后台配置支持。具体操作见官网文档[https://router.vuejs.org/zh/guide/essentials/history-mode.html vue-router使用方式通过 vue-cli 直接配置生成的 router/index.js 直接使用 通过包管理工具手动配置（基于vue-cli自动生成的目录） 1.下载直接下载 / CDN npm 1npm install vue-router cdn https://unpkg.com/vue-router/dist/vue-router.js 2.引入安装下载完成后 在router/index.js 文件中引入安装 1234import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter) 3.创建路由对象并配置路由规则router/index.js 1234567891011121314151617const routes = [ { path: '/', name: 'home', component: Home }, { path: '/about', name: 'about', component: About }]const router = new VueRouter({ // mode: 'history' HTML5 History 模式 routes}) 4.导出routes 导入main.jsrouter/index.js 1export default router src/main.js 1import router from './router' 5.挂载在src/main.js中 vue的实例挂载router 1234new Vue({ router, render: h =&gt; h(App)}).$mount('#app') 6.渲染src/App.vue 1234567891011121314&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div id=\"nav\"&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/\"&gt;Home&lt;/router-link&gt; | &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 简写&lt;router-view/&gt; --&gt; &lt;/div&gt;&lt;/template&gt;","link":"/2020/01/19/Vue.js/vue-router/"},{"title":"vuex中的辅助函数","text":"vuex中的辅助函数vuex提供了辅助函数处理庞大的vuex数据，mapState，mapGetters，mapMutations，mapActions，实际就是把state、getters、mutations、actions整合成一个数组，一次性返回 注意：mapState，mapGetters返回的是属性，所以混入到 computed 中，mapMutations，mapActions返回的是方法，只能混入到methods中 1234567891011121314151617181920212223&lt;template&gt; &lt;div v-if=\"user.userName\"&gt; &lt;span&gt;欢迎您：{{user.userName}}&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import {mapState,mapGetters,mapMutations,mapActions} from 'vuex'export default { name: 'App', mounted(){ console.log(mapGetters(['user']).user.call(this)) }, computed:{ ...mapGetters(['user']), //mapGetters(['user'])返回this.$store.getters.user对象，相当于以下代码 // user(){ // return this.$store.getters.user // } }}&lt;/script&gt; 使用辅助函数是把vuex中的getters等函数映射到vue中，调用时使用 this.user 即可调用 this.$store.getters.user 函数，传参时正常传参 注意：你在组件中可以使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用 12345678910111213import { mapActions } from 'vuex'export default { // ... methods: { ...mapActions([ 'increment' // 映射 this.increment() 为 this.$store.dispatch('increment') ]), ...mapActions({ add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment') }) }} 原文链接：https://blog.csdn.net/YUHUI01/article/details/84201419","link":"/2020/02/08/Vue.js/vuex%E4%B8%AD%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"},{"title":"vue生命周期","text":"介绍每个 Vue 实例在被创建时都要经过一系列的初始化过程。 例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。 同时在这个过程中也会运行一些叫做生命周期钩子的函数。 这给了用户在不同阶段添加自己的代码的机会。 注意生命周期钩子的 this 上下文指向调用它的 Vue 实例。不要在选项属性或回调上使用 箭头函数，因为箭头函数并没有 this。 作用让 开发者 控制整个vue实例的过程时 更好的添加逻辑。 图示 详情创建beforeCreate表示 实例完成被创建出来之前，会执行它 注意：在beforeCreate 生命周期函数执行的时候，data 和 methods 中的数据都没有初始化 created在 created 中 data 和 methods 都已经初始化好了 如果要调用 methods 中的方法 或者操作 data 中的数据，最早 只能在created 中操作 挂载beforeMount表示 模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中 在 beforeMount 执行的时候 页面中的元素 还没有被真正替换过来 只是之前写的一些模板字符串 mounted表示 内存中的模板 已经真实的挂载到了页面中 用户已经可以看到渲染好的页面 注意 mounted 是 实例创建期间的最后一个生命周期函数 当执行完mounted 就表示 实例已经被完全创建好了 此时 如果没有其它操作的话 这个实例 静静的 躺在内存中 一动不动 如果要通过某些插件操作页面上的DOM节点了 最早要在mounted中进行 此时 组件已经脱离了创建阶段 进入到了运行阶段 更新只有当 data 数据改变 可以执行0 或 无限次 beforeUpdate页面显示的数据 还是旧的 此时 data数据是最新的 页面和最新数据不同步 updated页面和 data 最新数据已经同步 都是最新的 销毁beforeDestroy当执行 beforeDestroy钩子函数的时候, Vue实例就已经从运行阶段，进入到了销毁阶段当执行 beforeDestroy 的时候,实例身上所有 data 和所有的 methods , 以及过滤器.指令…都处于可用状态,此时。还没有真正执行销毁的过程 destroyed当执行到destroyed函数的时候,组件已经被完全销毁了,此时,组件中所有的数据、方法、指令、 过滤…都已经不可用了 总结使用场景（欢迎评论补充）beforeCreate 请求数据 添加一些loading效果，在created时进行移除 created 请求数据， 完成数据的初始化 mounted 请求数据 当需要操作dom的时候执行 beforeUpdated updated 当数据更新需要做统一业务处理的时候使用 beforeDestroy 解绑事件 destroy","link":"/2020/01/17/Vue.js/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"vue项目打包优化","text":"在执行build命令期间移除所有的console安装 1npm install babel-plugin-transform-remove-console --save-dev 使用123456789// babel.config.jsmodule.exports = { presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ 'transform-remove-console' ]} 重新打包","link":"/2020/02/09/Vue.js/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"},{"title":"Vue路线规划","text":"扎实的HTML/CSS/JS基础(自学) HTML常用标签 CSS基础语法 Scoped CSS JS基础语法 new this ES6语法Object.defineProperty class 设计模式(看vue文档)MVC模式eventbus发布订阅mixin混入prototype原型extends继承依赖注入Vue API(写博客)组件data props methods watch computed template render 钩子 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 模板语法条件：v-if/v-else/v-else-if 循环：v-for 事件：v-on/v-once 属性：v-bind 特殊：v-model 其他：v-text/v-html/v-show/v-pre/v-cloak 过渡动画transition transition-group Webpack配置(说出作用，如何配置)vue-loader @vue/cli sass-loader/less-loader/stylus-loader babel-loader ts-loader eslint Vue全家桶(重要性递减)Vuexstate getter mutation action module Vue Routerhash模式 history模式 守卫 懒加载 Axios拦截器 RESTFul Jext/Mocha单元测试 mock/stub PWAservice worker HTTPS UI框架(了解一两个)ElementAnt Design Vueiviewcube-uiVant到这将成为vue快速开发者 Vue 3.0TypeScriptReact HooksProxy APIReactive 风格函数式编程高级(涉及数据结构和算法)虚拟DOMDiff算法模板编译","link":"/2020/01/05/Vue.js/vue%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/"},{"title":"webpack入门","text":"WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 核心概念入口(entry)入口起点(entry point)指示webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js 输出(output)output 属性告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist loader (加载器)webpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块。 在 webpack 的配置中 loader 有两个属性： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 插件(plugin)plugins(插件)作用更大，可以打包优化，资源管理和注入环境变量 模式(mode)通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。 基本配置以安装css-loader和安装html-webpack-plugin举例 安装 css-loader安装 style-loader 和 css-loader 1npm i -D style-loader css-loader 安装 html-webpack-plugin1npm i -D html-webpack-plugin 修改webpack.config.js** 12345678910111213141516171819202122232425const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { mode: 'development', // \"production\" | \"development\" | \"none\" entry: './entry.js', //入口文件 默认为 './src/index.js' output: { // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, 'dist'), // 输出文件的目标路径 必须是绝对路径 filename: 'foo.bundle.js' //打包后输出文件的文件名 }, module: { // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） { test: /\\.css$/, // 以.css结尾的文件 use: ['style-loader', 'css-loader'] // 使用这些loader处理 } ] }, plugins: [ new HtmlWebpackPlugin({ filename: \"/index.html\", // 生成的模板文件的名字 template: \"index.html\" // 模板来源文件 }) ]}; 常用的loader和plugin常见的Loader file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 常见的plugin define-plugin：定义环境变量 html-webpack-plugin：简化html文件创建 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 webpack-parallel-uglify-plugin: 多核压缩,提高压缩速度 webpack-bundle-analyzer: 可视化webpack输出文件的体积 mini-css-extract-plugin: CSS提取到单独的文件中,支持按需加载 参考链接 前端面试与进阶指南 webpack官网文档 webpack 从入门到放弃(一)","link":"/2020/03/02/Webpack/webpack%E5%85%A5%E9%97%A8/"},{"title":"Git常用操作","text":"Git操作解释 git status 查看当前项目中源代码的状态 git add . 全部添加到暂存区 git commit -m &quot;提交信息&quot; 把暂存区所有代码提交到本地仓库中 git branch 查看分支 *当前处于分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换到分支 git merge 分支名 合并分支（合并到本地，云端并没有） git push 把本地分支中最新的代码推送到远程仓库中 默认master主分支 git push -u origin 分支名 第一次推送到此分支的时候使用 Git常见操作 第一次提交代码至远程仓库 1.初始化git git init 2.提交全部文件git add . 3.提交到本地仓库 git commit -m “first commit” 4.关联远程仓库 git remote add origin 仓库地址 5.提交到远程仓库git push -u origin master 合并分支 1.切换到主分支 git checkout master 2.合并分支 git merge login 3.推送到云端（仓库）git push","link":"/2019/12/15/Git/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"Vue扫盲","text":"Uncaught SyntaxError: Unexpected token &lt; vue中一个标签中含有多个class，其中class有中包含三元表达式的写法1.数组形式： 1&lt;div :class='[\"classA\",data==\"0\"?\"classB\":\"\"]'&gt;aaaaa&lt;/div&gt; 注意：数组中的classA如果不加双引号的话，代表的是data中的一员，并不是类名，将classA加上双引号，变成字符串，就可以变成类名啦 2.字符串拼接 1&lt;div :class=\"'classA'+(data=='0'?' active':'')\"&gt;bbbbbb&lt;/div&gt; 注意：active前必须有一个空格，字符串拼接时，两个字符串之间要有空格 vue-awesome-swiper无法更改分页器样式。async awaitvue-cli项目部署GitHub Pages那么 vue.config.js 的内容应如下所示： 12345module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/my-project/dist' : '/'} 在dist中有index.html 为什么组件中的data必须是一个函数当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新 实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 Vue: export default中的name属性作用name 类型：string 限制：只有作为组件选项时起作用。 详细： 允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。 指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools ，未命名组件将显示成&lt;AnonymousComponent&gt;，这很没有语义。通过提供 name 选项，可以获得更有语义 信息的组件树。 vue-cli 3.x 的 views 和 components有什么区别？views是页面级组件 components是共享的小组件 containers是容器级组件（根据项目大小决定是否使用） 从组件大小级别区分 components &lt;（containers）&lt; views 简单理解成vue-router使用的组件是views就行了 列表渲染中的key值跟踪每个节点的身份，从而重用和重新排序现有元素 理想的key值是每项都有的且唯一的id (data.id ) 子路由规则的path属性不要以斜线/开头","link":"/2020/01/18/Vue.js/vue%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/"},{"title":"jQuery 学习笔记","text":"（整理不易，若有帮助，请给个Star⭐） jQuery概述JavaScript库 仓库:可以把很多东西放到这个仓库里面。 找东西只需要到仓库里面查找到就可以了。 JavaScript库:即library ,是一个封装好的特定的集合(方法和函数)。从封装大堆函数的角度理解库,就是在这个库中,封装了很多预先定义好的函数在里面,比如动画animate、hide、 show ,比如获取元素等。 简单理解:就是一个JS 文件,面对我们原生js代码进行了封装,存放到面。这样我们可以快速高效的使用这些封装好的功能了。 比如jQuery ,就是为了快速方便的操作DOM ,里面基本都是函数(方法)。 jQuery的概念 jQuery 是一个快速、简洁的JavaScript库,设计的宗旨是”write Less，Do More”, 即倡导写更少的代码,做更多的事情。 j就是JavaScript; Query 查询;意思就是查询js ,把js中的DOM操作做了封装,我们可以快速的查询使用里面的功能。 jQuery封装了JavaScript 常用的功能代码,优化了DOM操作、事件处理、动画设计和Ajax交互。学习jQuery本质:就是学习调用这些函数(方法)。 jQuery出现的目的是加快前端人员的开发速度,我们可以非常方便的调用和使用它,从而提高开发效率。 jQuery的优点 优点 轻量级。 核心文件才几+kb ,不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、 隐式迭代 对事件、 样式、动画支持,大大简化了DOM操作 支持插件扩 展开发。有着丰富的第三方的插件,例如: 树形菜单、日期控件、轮播图等 免费、开源 jQuery的基本使用jQuery的下载 官网下载地址：http://jquery.com/download/ jQuery版本有很多，分为1.x 2.x 3.x 1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。 关于压缩版和未压缩版： jquery.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。 jquery.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。 jQuery的使用步骤 1.引入jQuery文件 2.放置对应js文件 jQuery的入口函数12345678//第一种写法 $(function() { ... //此处是页面DOM加载完成的入口});//第二种写法 $(document).ready(function() { ... //此处是页面DOM加载完成的入口}); 1.等着DOM结构染完毕即可执行内部代码,不必等到所有外部资源加载完成, jQuery帮我们完成了封装。 2.相当于原生js中的DOMContentL oaded. 3.不同于原生js中的load事件是等页面文档、外部的js文件、Css文件、图片加载完毕才执行内部代码。 4.更推荐使用第一种方式。 jQuery的顶级对象$ 1.$是jQuery的别称,在代码中可以使用jQuery代替$,但一般为了便,通常都直接使用$。 2.$是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用$包装成jQuery对象,就可以调用jQuery的方法。 jQuery对象和DOM对象 1.用原生JS获取来的对象就是DOM对象 2.jQuery方法获取的元素就是jQuery对象。 3.jQuery对象本质是:利用$对DOM对象包装后产生的对象(伪数组形式存储)。 4.jQuery对象只能使用jQuery方法，DOM对象则使用原生的JS属性和方法。 DOM对象与jQuery对象之间是可以相互转换的。 因为原生js比jQuery更大,原生的一些属性和方法jQuery没有给我们封装要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 DOM对象转换为jQuery对象: $(DOM对象) 1$('div') jQuery对象转换为DOM对象(两种方式) 12$('div')[index] // index是索引号$('div').get(index) // index是索引号 jQuery选择器 原生JS获取元素方式很多,很杂,而且兼容性情况不一致,因此jQuery给我们做了封装,使获取元素统标准。 1$(\"选择器\") // 里面选择器直接写CSS选择器即可，但是要加引号 基本选择器（跟css的选择器用法一模一样） 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 全选选择器 $(“*”); 匹配所有元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 获取多个元素 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 层级选择器（跟css的选择器用法一模一样） 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 jQuery设置样式1$('div').css('属性','值') 隐式迭代(重要) 遍历内部DOM元素(伪数组形式存储)的过程就叫做隐式迭代。 简单理解:给匹配到的所有元素进行循环遍历,执行相应的方法,而不用我们再进行循环,简化我们的操作,方便我们调用。 jQuery筛选选择器(这类选择器都带冒号) 名称 用法 描述 :first $(“li:first”) 获取第一个li元素 :last $(“li:last”) 获取最后一个li元素 :eq（index） $(“li:eq(2)”) 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(“li:odd”) 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”) 获取到的li元素中，选择索引号为偶数的元素 jQuery筛选方法(重点)(筛选方法是方法) 名称 用法 描述 parent() $(“#first”).parent(); 查找父亲 parents(selector) $(“#first”).parents(); 找到所有的父亲，可以返回指定的元素 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，子类选择器 find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 hasClass(class) $(‘div’).hasClass(‘protected’) 检查当前元素是否有特定的类，有返回true eq(index) $(“li”).eq(2); 相当于$(“li:eq(2)”),index从0开始 重点： parent() children(selector) find(selector) siblings(selector) eq(index) jQuery样式操作操作CSS方法 jQuery可以使用CSS方法来修改简单元素样式;也可以操作类,修改多个样式。 1.参数只写属性名,则是返回属性值 1$(this).css(\"color\"); 2.参数是属性名,属性值,逗号分隔,是设置-组样式,属性必须加引号,值如果是数字可以不用跟单位和引号 1$(this).css(\"color\", \"red\"); 3.参数可以是对象形式,方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号, 1$(this).css({\"color\":\"white\",\"font-size\":\"20px\"); 设置类样式方法 作用等同于以前的classList ,可以操作类样式,注意操作类里面的参数不要加点。 1.添加类 1$(\"div\").addClass(\"current\"); 2.移除类 1$(\"div\").removeClass(\"current\"); 3.切换类 1$(\"div\").toggleClass(\"current\"); 类操作与className区别 原生JS中className会覆盖元素原先里面的类名。 jQuery里面类操作只是对指定类进行操作,不影响原先的类名。 jQuery效果显示隐藏效果 1.隐藏语法规范 1hide([speed],[easing],[fn]]) 2.隐藏参数 (1)参数都可以省略,无动画直接显示。(2) speed :三种预定速度之一 的字符串( “slow” ，”normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。(3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”Ilinear” 。(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。 滑动效果 1.滑动效果语法规范 123456// 下滑slideDown([speed],[easing],[fn]])// 上滑slideUp([speed],[easing],[fn]])// 切换slideToggle([speed],[easing],[fn]]) 2.滑动效果参数(1)参数都可以省略。(2) speed:三种预定速度之一 的字符串( “slow”，”normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。(3) easing:(Optional)用来指定切换效果,默认是”swing” ,可用参数”linear” 。(4) fn:回调函数,在动画完成时执行的函数,每个元素执行次。 动画队列及其停止排队方法 1.动画或效果队列 动画或者效果一旦触发就会执行 ,如果多次触发,就造成多个动画或者效果排队执行。 2.停止排队 1stop() (1) stop()方法用于停止动画或效果。 (2)注意: stop()写到动画或者效果的前面，相当于停止结束上一次的动画。 淡入淡出效果 1.淡入淡出语法规范 12345678// 淡入fadeIn([speed],[easing],[fn]])// 淡出fadeOut([speed],[easing],[fn]])// 切换fadeToggle([speed],[easing],[fn]])// 设置透明度 speed 和 opacity(0~1) 必须写fadeTo(speed,opacity,[easing],[fn]]) 2.淡入淡出效果参数(1)参数都可以省略。(2) speed:三种预定速度之一 的字符串( “slow”，”normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。(3) easing:(Optional)用来指定切换效果,默认是”swing” ,可用参数”linear” 。(4) fn:回调函数,在动画完成时执行的函数,每个元素执行次。 自定义动画animate 1.语法 1animate (params, [speed],[easing],[fn]) 2.参数(1) params:想要更改的样式属性,以对象形式传递,必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法borderLeft。其余参数都可以省略。(2) speed: 三种预定速度之一的字符串( “slow”，”normal” , or “fast” )或表示动画时长的毫秒数值(如 :1000)。(3) easing : (Optional)用来指定切换效果,默认是”swing” , 可用参数”Ilinear” 。(4) fn:回调函数,在动画完成时执行的函数, 每个元素执行次。 jQuery属性操作设置或获取元素固有属性值prop() 所谓元素固有属性就是元素本身自带的属性,比如&lt; a &gt;元素里面的href , 比如&lt; input &gt;元素里的type。 1.获取属性语法 1prop(\"属性\") 2.设置属性语法 1prop(\"属性\", \"属性值\") 设置或获取元素自定义属性值attr() 用户自己给元素添加的属性,我们称为自定义属性。比如给div添加index=“1”。 1.获取属性语法 1attr(\"属性\") // 类似原生getAttribute() 2.设置属性语法 1attr(\"属性\",\"属性值\") // 类似原生setAttribute() 改方法也可以获取H5自定义属性 数据缓存data() data(方法可以在指定的元素上存取数据,并不会修改DOM元素结构。- 旦页面刷新,之前存放的数据都将被移除。 1.附加数据语法 1data(\"name\",\"value\") // 向被选元素附加数据 2.获取数据语法 1date(\"name\") // 向被选元素获取数据 同时,还可以读取HTML5自定义属性data-index , 得到的是数字型 获取data-index h5自定义属性 不用写data- 返回的是数字型 jQuery内容文本值 主要针对元素的内容还有表单的值操作。 1.普通元素内容htmI() (相当于原生inner HTML) 12html() // 获取元素的内容html(\"内容\") // 设置元素的内容 2.普通元素文本内容text() (相当与原生 innerText) 12text() // 获取元素的文本内容text(\"文本内容\") // 设置元素的文本内容 主要针对元素的内容还有表单的值操作。 3.表单的值val() (相当于原生value) 1val() // 获取设置表单值 jQuery元素操作 主要是遍历、创建、添加、删除元素操作。 遍历元素 jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一元素做不同操作,就需要用到遍历。 语法1 :1$(\"div\").each(function(index, domEle){ xxx;}) 1.each(方法遍历匹配的每一个元素。 主要用DOM处理。each每一 个 2.里面的回调函数有2个参数: index 是每个元素的索引号; demEle是每个DOM元素对象,不是jquery对象 3.所以要想使用jquery方法,需要给这个dom元素转换为jquery对象$(domEle) 语法2 :1$.each(object,function (index, element) { xxx;}) 1.$.each(方法可用于遍历任何对象。主要用于数据处理,比如数组,对象2.里面的函数有2个参数: index 是每个元素的索引号; element遍历内容 创建元素 语法: 1$(\"&lt;li&gt;&lt;/li&gt;\"); 动态的创建了一一个&lt; li &gt; 添加元素 1.内部添加 把内容放入匹配元素内部最后面,类似原生appendChild。 12element.append(\"内容\") // 把内容放入目标元素后面element.prepend(\"内容\") // 把内容放入目标元素前面 2.外部添加 12element.after(\"内容\") // 把内容放入目标元素后面element.before(\"内容\") // 把内容放入目标元素前面 删除元素 语法: 123element.remove() // 删除匹配的元素(本身)element.empty() // 删除匹配的元素集合中所有的子节点element.html(\"\") // 清空匹配的元素内容 jQuery事件注册单个事件注册 语法: 12element.事件(function(){})$(\"div\").click(function(){事件处理程序}) 其他事件和原生基本一致。比如mouseover、mouseout、 blur、 focus、 change、 keydown、 keyup、 resize、 scroll等 jQuery事件处理事件处理on()绑定事件 on()方法在匹配元素上绑定一个或多个事件的事件处理函数 语法: 1element.on(events,[selector], fn) events:-个或多个用空格分隔的事件类型,如”lick’或”keydown”。 selector:元素的子元素选择器。 fn:回调函数即绑定在元素身上的侦听函数。 on()方法优势1 : 可以绑定多个事件,多个处理事件处理程序。 12345$(\"div\").on({ mouseover:function(){}, mouseout:function(){}, click:function(){}}); 如果事件处理程序相同 123$(\"div\").on(\"mouseover mouseout\", function() { $(this).toggleClass (\"current\");}); on()方法优势2 : 可以事件委派操作。事件委派的定义就是,把原来加给子元素身上的事件绑定在父元素身上,就是把事件委派给父元素。 123$('ul').on('click','li', function() { alert('hello world!');}); 在此之前有bind(), live() delegate(等方法来处理事件绑定或者事件委派,最新版本的请用on替代他们。 on0方法优势3 : 动态创建的元素, click()没有办法绑定事件，on() 可以给动态生成的元素绑定事件 事件处理off()解绑事件 off()方法可以移除通过on0方法添加的事件处理程序。 123$(\"p\").off() // 解绑p元素所有事件处理程序$(\"p\").off(\"click\") // 解绑p元素上面的点击事件后面的foo是侦听函数名$(\"ul\").off (\"click\", \"li\"); // 解绑事件委托 如果有的事件只想触发一次，可以使用one()来绑定事件。 1$(\"p\").one(\"click\") // 只能触发点击事件一次 自动触发事件trigger() 有些事件希望自动触发比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件,不必鼠标点击触发。 123456789101112131415161718element.click() // 第一种简写形式element.trigger (\"type\") //第二种自动触发模式$(\"p\").on(\"click\", function () { alert(\"hi~\");});$(\"p\").trigger (\"click\"); //此时自动触发点击事件,不需要鼠标点击element.triggerHandler(\"type\") // 第三种自动触发模式// 3.元素. triggerHandler(\"事件\") 就是不会触发元素的默认行为// 获取文本框焦点案例，光标闪烁是获取文本框的默认事件$(\"input\").on(\"focus\", function() { $(this).val(\"你好吗\");});// $(\"input\").trigger(\"focus\")；// 会触发事件 光标会闪烁$(\"input\").triggerHandler(\"focus\");// 会触发事件 光标不会闪烁 jQuery事件对象 事件被触发,就会有事件对象的产生。 1element.on(events,[selector],function (event) { }) 阻止默认行为: event.preventDefault() 或者 return false 阻止冒泡: event.stopPropagation() jQuery对象拷贝 如果想要把某个对象拷贝(合并)给另外-一个对象使用,此时可以使用$. extend()方法语法: 1$.extend ([deep], target, object1, [objectN]) deep:如果设为true为深拷贝，默认为false浅拷贝 target:要拷贝的目标对象 object1:待拷贝到第一个对象的对象。 objectN:待拷贝到第N个对象的对象。 浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象,修改目标对象会影响被拷贝对象。 深拷贝,前面加true，完全克隆(拷贝的对象，而不是地址) ,修改目标对象不会影响被拷贝对象。 jQuery多库共存 问题概述: jQuery使用$作为标示符,随着jQuery的流行，其他js库也会用这$作为标识符,这样一起使用会引起冲突。 客观需求: 需要一个解决方案,让jQuery和其他的js库不存在冲突,可以同时存在,这就叫做多库共存。 jQuery解决方案: 1.把里面的$符号统-改为jQuery。比如jQuery(“div”)2.jQuery变量规定新的名称: $.noConflict() var xx = $.noConflict(); jQuery插件 jQuery功能比较有限,想要更复杂的特效效果,可以借助于jQuery插件完成。 注意:这些插件也是依赖于jQuery来完成的,所以必须要先引入jQuery文件,因此也称为jQuery插件。 jQuery插件常用的网站: 1.jQuery插件库http://www.jq22.com/ 2.jQuery之家http://www.htmleaf.com/ jQuery插件使用步骤: 1.引入相关文件。( jQuery文件和插件文件) 2.复制相关html、Css、 js (调用插件)。 jQuery插件演示: 1.瀑布流 2.图片懒加载(图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载)当我们页面滑动到可视区域,再显示图片。 我们使用jquery插件库EasyLazyload。 注意,此时的js引入文件和js调用必须写到DOM元素(图片)最后面 3.全屏滚动( fullpage.js ) gitHub : https://github.com/alvarotigo/fullPage.jis 中文翻译网站: http://www.dowebok.com/demo/2014/77/ bootstrap JS插件: bootstrap框架也是依赖于jQuery开发的,因此里面的js插件使用,也必须引入jQuery文件。 jQuery尺寸、位置操作jQuery 尺寸 语法 用法 width()/height() 取得匹配元素宽度和高度值只算width / height innerWidth()/innerHieght) 取得匹配元素宽度和高度值包含padding outerWidth() /outerHeight() 取得匹配元素宽度和高度值包含padding、border outerWidth(true) / outerHeight(true) 取得匹配元素宽度和高度值包含padding、borde、 margin 以上参数为空,则是获取相应值,返回的是数字型。 如果参数为数字,则是修改相应值。 参数可以不必写单位。 jQuery位置位置主要有三个: offset()、position()、 scrollTop()/scrollLeft() offset()设置或获取元素偏移①offset() 方法设置或返回被选元素相对于文档的偏移坐标,跟父级没有关系。 position()获取元素偏移①position()方法用于返回被选元素相对于带有定位的父级偏移坐标,如果父级都没有定位,则以文档为准。 scrollTop()/scrollLeft()设置或获取元素被卷去的头部和左侧①scrollTop() 方法设置或返回被选元素被卷去的头部。 案例:带有动画的返回顶部 ①核心原理:使用animate动画返回顶部。②animate动画函数里面有个scrolITop属性,可以设置位置③但是是元素做动画,因此$(“body,html”).animate({scrollTop: 0})","link":"/2019/12/31/jQuery/jQuery%E7%AC%94%E8%AE%B0/"},{"title":"express 学习笔记","text":"Express使用Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。我们可以使用 npm install express 命令进行下载。 1234567891011// 引入Express框架const express = require('express');// 使用框架创建web服务器const app = express();// 当客户端以get方式访问/路由时app.get('/', (req, res) =&gt; { // 对客户端做出响应 send方法会根据内容的类型自动设置请求头 res.send('Hello Express'); // &lt;h2&gt;Hello Express&lt;/h2&gt; {say: 'hello'}});// 程序监听3000端口app.listen(3000); 什么是中间件中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。 中间件主要由两部分构成，中间件方法以及请求处理函数。中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。 12app.get('请求路径', '处理函数') // 接收并处理get请求app.post('请求路径', '处理函数') // 接收并处理post请求 可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。 1234567app.get('/request', (req, res, next) =&gt; { req.name = \"张三\"; next();});app.get('/request', (req, res) =&gt; { res.send(req.name);}); app.use中间件用法app.use 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。 1234app.use((req, res, next) =&gt; { console.log(req.url); next();}); app.use 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。 1234app.use('/admin', (req, res, next) =&gt; { console.log(req.url); next();}); 中间件应用路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。自定义404页面 错误处理中间件在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。 123app.use((err, req, res, next) =&gt; { res.status(500).send('服务器发生未知错误');}) 当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件。 1234567 app.get(\"/\", (req, res, next) =&gt; { fs.readFile(\"/file-does-not-exist\", (err, data) =&gt; { if (err) { next(err); } });}); 捕获错误在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。异步函数执行如果发生错误要如何捕获错误呢？ try catch 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。 1234567app.get(\"/\", async (req, res, next) =&gt; { try { await User.find({name: '张三'}) }catch(ex) { next(ex); }}); 构建模块化路由123456// home.jsconst home = express.Router(); home.get('/index', () =&gt; { res.send('欢迎来到博客展示页面');});module.exports = home; 123// app.jsconst home = require('./route/home.js');app.use('/home', home); GET参数的获取Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。 12345// 接收地址栏中问号后面的参数// 例如: http://localhost:3000/?name=zhangsan&amp;age=30app.get('/', (req, res) =&gt; { console.log(req.query); // {\"name\": \"zhangsan\", \"age\": \"30\"}}); POST参数的获取Express中接收post请求参数需要借助第三方包 body-parser。 123456789// 引入body-parser模块const bodyParser = require('body-parser');// 配置body-parser模块app.use(bodyParser.urlencoded({ extended: false }));// 接收请求app.post('/add', (req, res) =&gt; { // 接收请求参数 console.log(req.body);}) Express路由参数1234// localhost:3000/find/123app.get('/find/:id', (req, res) =&gt; { console.log(req.params); // {id: 123} }); 静态资源的处理通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。 1app.use(express.static('public')); 现在，public 目录下面的文件就可以访问了。 http://localhost:3000/images/kitten.jpg http://localhost:3000/css/style.css http://localhost:3000/js/app.js http://localhost:3000/images/bg.png http://localhost:3000/hello.html","link":"/2020/03/19/Node.js/express%E5%85%A5%E9%97%A8/"},{"title":"mongoDB 学习笔记","text":"MongoDB是一种面向文档的非关系型(NoSQL)数据库 术语 解释说明 database 数据库，mongoDB数据库软件中可以建立多个数据库 collection 集合，一组数据的集合，可以理解为JavaScript中的数组 document 文档，一条具体的数据， 可以理解为JavaScript中的对象 field 字段，文档中的属性名称，可以理解为JavaScript中的对象属性 Mongoose第三方包使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose 启动MongoDB在命令行工具中运行net start mongoDB即可启动MongoDB,否则MongoDB将无法连接。 数据库连接使用mongoose提供的connect方法即可连接数据库。 123mongoose.connect ('mongodb://localhost/playground',{useNewUrlParser: true}) .then(() =&gt; console.1og('数据库连接成功')) .catch(err =&gt; console.log('数据库连接失败'，err)) ; 创建数据库,在MongoDB中不需要显式创建数据库，如果正在使用的数据库不存在，MongoDB会自动创建。 创建集合创建集合分为两步，-是对对集合设定规则，二是创建集合,创建mongoose.Schema构造函数的实例即可创建集合。 12345678//设定集合规则const courseSchema = new mongoose.Schema({ name: String, author: String, isPublished: Boolean}) ;//创建集合并应用规则 首字母大写const Course = mongoose.model('Course',courseSchema); // courses 创建文档创建文档实际上就是向集合中插入数据。分为两步:①创建集合实例。②调用实例对象下的save方法将数据保存到数据库中。 123456789//创建集合实例const course = new Course ({ name: 'Node.js course', author: '黑马讲师', tags: ['node','backend'], isPublished: true}) ;//将数据保存到数据库中course.save () ; 创建文档123456Course.create ({name:'JavaScript基础',author: '黑马讲师',isPublish: true}, (err, doc) =&gt; {//错误对象console.log (err)//当前插入的文档console.log (doc)}); 123Course.create ({name: ' JavaScript基础'，author: ' 黑马讲师'，isPublish: true}).then(doc =&gt; console. log (doc) ).catch(err =&gt; console. log(err) ) mongoDB数据库导入数据mongoimport -d数据库名称-c集合名称-file要导入的数据文件 查询文档12345678910111213//根据条件查找文档(条件为空则查找所有文档) Course.find().then(result =&gt; console. log (result) )//返回文档集合 数组[{_id: 5c0917ed37ec9b03c07cf95f ，name :'node. js基础'author: ' 黑马讲师、},{id: 5c09dea28acfb814980ff827 ,name:' Javascript ' ,author:，黑马讲师、}] 查询文档123456789// findOne方法返回一条文档默认返回当前集合中的第一条文档 返回对象Course.findone ( {name :'node. js基础' }). then (result =&gt; console. log (result) )//返回文档 对象{id: 5c091 7ed37ec9b03c07cf95f ,name: 'node. js基础'，author: '黑马 讲师、} 查询文档12345678910//匹配 大于$gt 小于$ltUser.find({age: {$gt: 20，$lt: 50}}).then (result =&gt; console.log(result))//匹配包含User.find({hobbies: {$in: ['敲代码']}}).then(result =&gt; console.log(result))//选择要查询的字段 字段前面加上'-' 不显示User.find().select('name email') . then(result =&gt; console.log(result))//将数据按照年龄进行排序 默认升序 '-age'降序User.find().sort('age') . then(result =&gt; console.log(result))// skip 跳过多少条数据limit 限制查询数量User.find().skip(2).limit(2).then(result =&gt; console.log (result)) 删除文档12345678//删除单个//查找到一条文档并且删除//返回删除的文档//如何查询条件匹配了多个文档那么将会删除第个匹配的文档Course.findOneAndDelete({}).then(result =&gt; console.log(result))//删除多个//返回对象{n:4,ok:1} n数据数量，ok:1 删除成功User.deleteMany({}).then(result =&gt; console.log(result)) 更新文档1234//更新单个 n受影响的数据 nModified修改了几条数据 ok:1 成功User.updateOne({查询条件}, {要修改的值}).then(result =&gt; console.log(result))//更新多个 查询条件为空{} 匹配所有User.updateMany({查询条件}, {要更改的值}).then(result =&gt; console.log(result)) mongoose验证在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败。 required: true必传字段 minlength: 3字符串最小长度 maxlength: 20字符串最大长度 min: 2数值最小为2 max: 100数值最大为100 enum: [‘html’,’css’,’javascript’,’node.js’] trim: true去除字符串两边的空格 validate: 自定义验证器 123456789101112131415161718192021222324252627282930313233343536373839404142434445const postSchema = new mongoose . Schema({title: {type: String,//必选字段required: [true, '请传入文章标题']，//字符串的最小长度minlength: [2, '文章长度不能小于2'],//字符串的最大长度maxlength: [5, '文章长度最大不能超过5'],//去除字符串两边的空格trim: true}, age:{ type:Number, min:18, max:100 }, publishDate:{ type: Date, // 默认值 default:Date.now }, category:{ type:String, // 列举出当前字段可以拥有的值 enum:{ values:['html','css','js','node'], message:'分类名称要在范围内才可以' } }， author:{ type:String, // 自定义验证规则 validate:{ validator: v =&gt;{ // 返回布尔值 // true/false 成功/失败 // v 要验证的值 return v &amp;&amp; v.length &gt; 4 }, // 自定义错误信息 message:'传入的值不符合验证规则' } }}); 获取错误信息1234567891011121314151617const Post = mongoose . model( 'Post', IpostSchema) ;Post.create( {title: ' aa '，age: 60, category: ' java'，author: ' bd'})then(result =&gt; console .1og( result) )catch(error =&gt; {I//获取错误信息对象consterr =error . errors ;//循环错误信息对象for (var attrin err) {//将错误信息打印到控制台中console . log(err[attr][ ' message']);}}) 集合关联通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。 123456789101112// 用户集合const User = mongoose.model('User', new mongoose.Schema({ name: { type: String } })); // 文章集合const Post = mongoose.model('Post', new mongoose.Schema({ title: { type: String }, // 使用ID将文章集合和作者集合进行关联 author: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }}));//联合查询Post.find() .populate('author') .then((err, result) =&gt; console.log(result));","link":"/2020/03/17/mongoDB/mongDB%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"BFC","slug":"BFC","link":"/tags/BFC/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"ES7","slug":"ES7","link":"/tags/ES7/"},{"name":"Proxy","slug":"Proxy","link":"/tags/Proxy/"},{"name":"SCSS","slug":"SCSS","link":"/tags/SCSS/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"AMD","slug":"AMD","link":"/tags/AMD/"},{"name":"CMD","slug":"CMD","link":"/tags/CMD/"},{"name":"CommonJs","slug":"CommonJs","link":"/tags/CommonJs/"},{"name":"ES6 Module","slug":"ES6-Module","link":"/tags/ES6-Module/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"箭头函数","slug":"箭头函数","link":"/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"deep clone","slug":"deep-clone","link":"/tags/deep-clone/"},{"name":"shallow clone","slug":"shallow-clone","link":"/tags/shallow-clone/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"vue-cli","slug":"vue-cli","link":"/tags/vue-cli/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"mongoDB","slug":"mongoDB","link":"/tags/mongoDB/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"ES6+","slug":"ES6","link":"/categories/ES6/"},{"name":"Git操作","slug":"Git操作","link":"/categories/Git%E6%93%8D%E4%BD%9C/"},{"name":"HTTPS","slug":"HTTPS","link":"/categories/HTTPS/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"mongoDB","slug":"mongoDB","link":"/categories/mongoDB/"}]}