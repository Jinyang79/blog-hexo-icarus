{"pages":[],"posts":[{"title":"学习日记","text":"11月30日第一次使用typora写日记 创建了个人网站 http://jinyang7.web3v.vip/ 网站简历素材学习 完善简历个人技能 项目经验没写 明天看jQuery 完善简历 12月1日完成的简历，投了宙源科技 准备最近可能的面试 装修个人网站 12月2日复习项目经历rem+flex vue 复习js 完成了music优化 12月3日vue学习p368 复习了axios 12月4日学习了 router webpack 复习了vue-cli脚手架创建 了解了vuex 12月5日vue学习视频p374完成了登录功能并上传码云 学习了git基本用法 电商后台管理系统完成home 的header vue视频p379 https://www.bilibili.com/video/av62487508复习原型 12月6日复习了原型 原型链 解析构造 完成了aside侧边栏菜单获取渲染数据p380 12月7日电商后台管理系统p386https://www.bilibili.com/video/av50680998?p=386 复习vue生命周期函数 完成侧边栏数据获取p390https://www.bilibili.com/video/av50680998?p=390 12月8日作用域插槽 123&lt;templata slot-scope=\"scope\"&gt; // scope.row 中包含当前行中的所有数据 {{scope.row}} 电商后台管理系统p399https://www.bilibili.com/video/av50680998?p=399 12月9日视频p409https://www.bilibili.com/video/av50680998?p=409 完成了添加用户，修改用户，表单验证，预验证 12月10日完成用户列表功能的开发（分支user 合并到master） 创建新分支rights（权限） 看到P430分配权限 做到p422 expand展开数据渲染 完成Right,Roles数据渲染 （重复的功能）Roles中添加角色，编辑，删除功能明天实现 12月11日上午完成了Roles的重复功能 完成展开数据渲染 样式没写 视频P434 整理学习视频https://pan.baidu.com/s/1YvqbO1mnnXzvALQRbdmTfw 12月12日完成了权限功能的开发p440 推送到rights分支，合并到master主分支 12月13日创建子分支goods_cate goods Cate.vue 使用了vue-table-with-tree-grid插件进行表格渲染 视频453 12月14日 管理后台系统BUG：点击编辑按钮 清空可以为空的数据（roles角色描述） 无法保存 ​ BUG: 重新获取数据（this.getCateList()）时，展开项会关闭 完成了分类功能的开发，推送到goods_cate分支，合并到master主分支 视频457 12月15日创建goods_params分支 了解计算属性computed 监听器watch P235 p468 获取的data 不需要分情况 tableData接收的数据 请求参数是动态 传过来的data就是动态数据 反之静态 P470 12月16日完成了分类参数的开发p485 推送到goods_params分支，合并到master主分支 12月17日GitHub创建Learning-diary.github.io vue-shop 同步到GitHub P505 12月18日 bug商品列表和商品分类编辑按钮无法预验证 商品列表编辑提交未实现 完成商品功能开发 推送到goods_list分支，合并到master主分支 视频521 12月19日了解vueP743https://www.bilibili.com/video/av74867960?p=746 P529完成订单功能的开发 推送到order分支，合并到master主分支 p535完成了报表功能的开发 推送到report分支，合并到master主分支 基本使用Echarts图表库 p536进入项目优化 12月20日p536项目优化 完成项目推送到云端 ！复习 p550项目上线 12月21日将桌面改成E盘E:\\Users\\Administrator\\Desktop 重新搭建node环境 将电商后台项目打包部署到个人网站http://jinyang7.web3v.vip/ bug打包的项目渲染有问题 12月22日解决了项目打包的项目渲染有问题：引入csn版本有问题 项目个人logo优化 通过hexo搭建个人博客 12月23日在腾讯云购买了域名goldsheep.club（1元/年）需要解析需要备案 48小时后 三丰云免费空间需要购买域名 放弃 使用liulongbing的后台api接口，完成电商后台项目 继续学习vuex https://www.bilibili.com/video/av74867960?p=757 视频757 创建并初始化vue_todos项目","link":"/2019/11/30/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"title":"学习笔记","text":"Git常见操作 git status 查看当前项目中源代码的状态 git add . 全部添加到暂存区 git commit -m &quot;提交信息&quot; 把暂存区所有代码提交到本地仓库中 git branch 查看分支 *当前处于分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换到分支 git merge 分支名 合并分支（合并到本地，云端并没有） git push 把本地分支中最新的代码推送到远程仓库中 默认master主分支 git push -u origin 分支名 第一次推送到此分支的时候使用 分支（login）合并到主分支（master） 1.切换到主分支 git checkout master 2.合并分支 git merge login 3.推送到云端（仓库）git push get和post请求区别 还有哪些http method get和post本质上没有区别，他们都是http的请求方式，基于tcp协议，但因为在不同的浏览器实现，就有了不同。 get请求的数据放在url上，post请求的数据放在http的包体内，所以说post相对get更安全。 get是通过URL提交数据，因此get提交数据根据url长度有关，不同的浏览器不同，一般是2k，而post理论上是没有限制的。 get幂等，post不幂等。 幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他请求方式（http method） head、put、delete、trace、connect、options vue的computed属性和methods区别最大的区别是缓存 计算属性是基于它们的依赖进行缓存的 方法不存在缓存 computed是响应式的，methods并非响应式。 调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。 computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的 初始化数据123456// 字符串string:'',// 数组array:[],// 数字number：0 vue过滤器p237 生命周期p239 render12345new Vue({ render: h =&gt; h(App)}).$mount('#app') render: h =&gt; h(App) 渲染到APP组件 $mount(‘#app’) 挂载到#app上 这是Vue 2.0新增的函数，可以直接给绑定节点渲染一个vue组件，如果在Vue 1.x下，就应该使用 1234new Vue({ el: '#app', components: { App }}); 然后在页面中写入标记： 123&lt;div id=&quot;app&quot;&gt; &lt;app&gt;&lt;/app&gt;&lt;/div&gt;","link":"/2019/12/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"My New Post","text":"","link":"/2019/12/24/My-New-Post/"},{"title":"面试题","text":"get和post请求区别 还有哪些http methodget和post本质上没有区别，他们都是http的请求方式，基于tcp协议，但因为在不同的浏览器实现，就有了不同。 get请求的数据放在url上，post请求的数据放在http的包体内，所以说post相对get更安全。 get是通过URL提交数据，因此get提交数据根据url长度有关，不同的浏览器不同，一般是2k，而post理论上是没有限制的。 get幂等，post不幂等。 幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他请求方式（http method） head、put、delete、trace、connect、options js数据类型undefined 未定义类型 null 空类型 boolean 布尔类型 number 数值型 string 字符串类型 symbol １种复杂数据类型：object —— 对象类型 csscalc, support, media各自的含义及用法？@support主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。 calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-“, “*”, “/“ 运算； @media 查询，你可以针对不同的媒体类型定义不同的样式。 css水平、垂直居中的写法，请至少写出4种？ 这题考查的是css的基础知识是否全面，所以平时一定要注意多积累 水平居中 行内元素: text-align: center 块级元素: margin: 0 auto position:absolute +left:50%+ transform:translateX(-50%) display:flex + justify-content: center 垂直居中 设置line-height 等于height position：absolute +top:50%+ transform:translateY(-50%) display:flex + align-items: center display:table+display:table-cell + vertical-align: middle; 1rem、1em、1vh、1px各自代表的含义？ rem rem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。 em 子元素字体大小的em是相对于父元素字体大小 元素的width/height/padding/margin用em的话是相对于该元素的font-size vw/vh 全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。 px px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 一般电脑的分辨率有{1920*1024}等不同的分辨率 1920*1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素 画一条0.5px的直线？ 考查的是css3的transform 12height: 1px;transform: scale(0.5); 说一下盒模型？ 盒模型是css中重要的基础知识，也是必考的基础知识 盒模型的组成，由里向外content,padding,border,margin. 在IE盒子模型中，width表示content+padding+border这三个部分的宽度 在标准的盒子模型中，width指content部分的宽度 box-sizing的使用 12box-sizing: content-box 是W3C盒子模型box-sizing: border-box 是IE盒子模型 box-sizing的默认属性是content-box 画一个三角形？ 这属于简单的css考查，平时在用组件库的同时，也别忘了原生的css 12345678910 .a{ width: 0; height: 0; border-width: 100px; border-style: solid; border-color: transparent #0099CC transparent transparent; transform: rotate(90deg); /*顺时针旋转90°*/ }&lt;div class=\"a\"&gt;&lt;/div&gt; 清除浮动的几种方式，及原理？ 清除浮动简单，但这题要引出的是BFC，BFC也是必考的基础知识点 ::after / / clear: both 创建父级 BFC(overflow:hidden) 父级设置高度 BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 触发条件: 根元素 position: absolute/fixed display: inline-block / table float 元素 ovevflow !== visible 规则: 属于同一个 BFC 的两个相邻 Box 垂直排列 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 文字层不会被浮动层覆盖，环绕于周围 html说一下标签的用法label标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验 遍历A节点的父节点下的所有子节点 这题考查原生的js操作dom,属于非常简单的基础题，但长时间使用mvvm框架，可能会忘记 1234&lt;script&gt; var b=document.getElementById(\"a\").parentNode.children; console.log(b)&lt;/script&gt; js用js递归的方式写1到100求和？ 递归我们经常用到，vue在实现双向绑定进行数据检验的时候用的也是递归，但要我们面试的时候手写一个递归，如果对递归的概念理解不透彻，可能还是会有一些问题。 123456789function add(num1,num2){ var num = num1+num2; if(num2+1&gt;100){ return num; }else{ return add(num,num2+1) } }var sum =add(1,2); 页面渲染html的过程？ 不需要死记硬背，理解整个过程即可 浏览器渲染页面的一般过程： 1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。 2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。 3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。 DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。 4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。 以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。 说一下CORS？CORS是一种新标准，支持同源通信，也支持跨域通信。fetch是实现CORS通信的 如何中断ajax请求？一种是设置超时时间让ajax自动断开，另一种是手动停止ajax请求，其核心是调用XML对象的abort方法，ajax.abort() 说一下事件代理？事件委托是指将事件绑定到目标元素的父元素上，利用冒泡机制触发该事件 123456ulEl.addEventListener('click', function(e){ var target = event.target || event.srcElement; if(!!target &amp;&amp; target.nodeName.toUpperCase() === \"LI\"){ console.log(target.innerHTML); }}, false); target、currentTarget的区别？currentTarget当前所绑定事件的元素 target当前被点击的元素 说一下宏任务和微任务？ 宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。 微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick等等）。 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。 说一下继承的几种方式及优缺点？ 说比较经典的几种继承方式并比较优缺点就可以了 借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上 原型继承，将子对象的prototype指向父对象的一个实例 组合继承 原型链继承的缺点 字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 说一下闭包？闭包的实质是因为函数嵌套而形成的作用域链 闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包 export和export default的区别？使用上的不同 12345export default xxximport xxx from './'export xxximport {xxx} from './' 说一下自己常用的es6的功能？ 此题是一道开放题，可以自由回答。但要注意像let这种简单的用法就别说了，说一些经常用到并有一定高度的新功能 像module、class、promise等，尽量讲的详细一点。 什么是会话cookie,什么是持久cookie?cookie是服务器返回的，指定了expire time（有效期）的是持久cookie,没有指定的是会话cookie 数组去重？ 此题看着简单，但要想面试官给你高分还是有难度的。至少也要写出几种方法 js 1234567891011121314151617181920212223242526272829303132333435var arr=['12','32','89','12','12','78','12','32']; // 最简单数组去重法 function unique1(array){ var n = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++){ //遍历当前数组 if (n.indexOf(array[i]) == -1) n.push(array[i]); } return n; } arr=unique1(arr); // 速度最快， 占空间最多（空间换时间） function unique2(array){ var n = {}, r = [], type; for (var i = 0; i &lt; array.length; i++) { type = typeof array[i]; if (!n[array[i]]) { n[array[i]] = [type]; r.push(array[i]); } else if (n[array[i]].indexOf(type) &lt; 0) { n[array[i]].push(type); r.push(array[i]); } } return r; } //数组下标判断法 function unique3(array){ var n = [array[0]]; //结果数组 for(var i = 1; i &lt; array.length; i++) { //从第二项开始遍历 if (array.indexOf(array[i]) == i) n.push(array[i]); } return n; } es6 123456es6方法数组去重arr=[...new Set(arr)];es6方法数组去重，第二种方法function dedupe(array) { return Array.from(new Set(array)); //Array.from()能把set结构转换为数组} get、post的区别 此题比较简单，但一定要回答的全面 1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内 2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制 3.get后退不会有影响，post后退会重新进行提交 4.get请求可以被缓存，post不可以被缓存 5.get请求只URL编码，post支持多种编码方式 6.get请求的记录会留在历史记录中，post请求不会留在历史记录 7.get只支持ASCII字符，post没有字符类型限制 你所知道的http的响应码及含义？ 此题有过开发经验的都知道几个，但还是那句话，一定要回答的详细且全面。 1xx(临时响应) 100: 请求者应当继续提出请求。 101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。 2xx(成功) 200：正确的请求返回正确的结果 201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。 202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。 3xx(已重定向) 300：请求成功，但结果有多种选择。 301：请求成功，但是资源被永久转移。 303：使用 GET 来访问新的地址来获取资源。 304：请求的资源并没有被修改过 4xx(请求错误) 400：请求出现错误，比如请求头不对等。 401：没有提供认证信息。请求的时候没有带上 Token 等。 402：为以后需要所保留的状态码。 403：请求的资源不允许访问。就是说没有权限。 404：请求的内容不存在。 5xx(服务器错误) 500：服务器错误。 501：请求还没有被实现。","link":"/2019/12/21/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"学习日记","slug":"学习日记","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"}]}