{"pages":[{"title":"个人简介","text":"微博 @瑾阳恰饱了饭说起从前 微信 17371438861 QQ 827126732 ❤️ 前端小白 ❤️ 欢迎大家 ❤️ 共同学习 如有侵权，请联系我哦","link":"/about/index.html"}],"posts":[{"title":"Git常用操作","text":"Git操作解释 git status 查看当前项目中源代码的状态 git add . 全部添加到暂存区 git commit -m &quot;提交信息&quot; 把暂存区所有代码提交到本地仓库中 git branch 查看分支 *当前处于分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换到分支 git merge 分支名 合并分支（合并到本地，云端并没有） git push 把本地分支中最新的代码推送到远程仓库中 默认master主分支 git push -u origin 分支名 第一次推送到此分支的时候使用 Git常见操作 第一次提交代码至远程仓库 1.初始化git git init 2.提交全部文件git add . 3.提交到本地仓库 git commit -m “first commit” 4.关联远程仓库 git remote add origin 仓库地址 5.提交到远程仓库git push -u origin master 合并分支 1.切换到主分支 git checkout master 2.合并分支 git merge login 3.推送到云端（仓库）git push","link":"/2019/12/15/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"Git版本回退","text":"(参考廖雪峰的Git教程) (已经git add file 并且 git commit -m 提交信息 但没推送云端 想回到上个版本或其他版本) 回退版本 ❗git reset --hard 版本号/HEAD^ ：命令回退到指定的版本号/上一次 ❗ 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位 ❗ 用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 查看提交历史版本号信息git log ：命令显示从最近到最远的提交日志 123456$ git logcommit commit id（版本号） (HEAD -&gt; master)Author: 提交作者Date: 提交时间 提交的内容 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数 1234$ git log --pretty=onelinecommit id（上次版本号） (HEAD -&gt; master) 上次提交的内容commit id（上上次版本号） 上上次提交的内容commit id（上上上次版本号） 上上上次提交的内容 坑❗ 输入q退出查看记录 后悔药💊在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到上个版本时，再想恢复原来，就必须找到原来的commit id（版本号）。Git提供了一个命令git reflog用来记录你的每一次命令： 123$ git refloge475afc HEAD@{1}: reset: moving to HEAD^版本号 (HEAD -&gt; master) HEAD@{2}: commit: 提交信息 ❗ 输入q退出查看记录 然后可以通过git reset --hard 版本号 恢复啦😁","link":"/2020/01/05/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"},{"title":"Icarus主题搭建技巧","text":"","link":"/2019/12/01/Icarus%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E6%8A%80%E5%B7%A7/"},{"title":"jQuery笔记","text":"（整理不易，若有帮助，请给个Star⭐） jQuery概述JavaScript库 仓库:可以把很多东西放到这个仓库里面。 找东西只需要到仓库里面查找到就可以了。 JavaScript库:即library ,是一个封装好的特定的集合(方法和函数)。从封装大堆函数的角度理解库,就是在这个库中,封装了很多预先定义好的函数在里面,比如动画animate、hide、 show ,比如获取元素等。 简单理解:就是一个JS 文件,面对我们原生js代码进行了封装,存放到面。这样我们可以快速高效的使用这些封装好的功能了。 比如jQuery ,就是为了快速方便的操作DOM ,里面基本都是函数(方法)。 jQuery的概念 jQuery 是一个快速、简洁的JavaScript库,设计的宗旨是”write Less，Do More”, 即倡导写更少的代码,做更多的事情。 j就是JavaScript; Query 查询;意思就是查询js ,把js中的DOM操作做了封装,我们可以快速的查询使用里面的功能。 jQuery封装了JavaScript 常用的功能代码,优化了DOM操作、事件处理、动画设计和Ajax交互。学习jQuery本质:就是学习调用这些函数(方法)。 jQuery出现的目的是加快前端人员的开发速度,我们可以非常方便的调用和使用它,从而提高开发效率。 jQuery的优点 优点 轻量级。 核心文件才几+kb ,不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、 隐式迭代 对事件、 样式、动画支持,大大简化了DOM操作 支持插件扩 展开发。有着丰富的第三方的插件,例如: 树形菜单、日期控件、轮播图等 免费、开源 jQuery的基本使用jQuery的下载 官网下载地址：http://jquery.com/download/ jQuery版本有很多，分为1.x 2.x 3.x 1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。 关于压缩版和未压缩版： jquery.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。 jquery.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。 jQuery的使用步骤 1.引入jQuery文件 2.放置对应js文件 jQuery的入口函数12345678//第一种写法 $(function() { ... //此处是页面DOM加载完成的入口});//第二种写法 $(document).ready(function() { ... //此处是页面DOM加载完成的入口}); 1.等着DOM结构染完毕即可执行内部代码,不必等到所有外部资源加载完成, jQuery帮我们完成了封装。 2.相当于原生js中的DOMContentL oaded. 3.不同于原生js中的load事件是等页面文档、外部的js文件、Css文件、图片加载完毕才执行内部代码。 4.更推荐使用第一种方式。 jQuery的顶级对象$ 1.$是jQuery的别称,在代码中可以使用jQuery代替$,但一般为了便,通常都直接使用$。 2.$是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用$包装成jQuery对象,就可以调用jQuery的方法。 jQuery对象和DOM对象 1.用原生JS获取来的对象就是DOM对象 2.jQuery方法获取的元素就是jQuery对象。 3.jQuery对象本质是:利用$对DOM对象包装后产生的对象(伪数组形式存储)。 4.jQuery对象只能使用jQuery方法，DOM对象则使用原生的JS属性和方法。 DOM对象与jQuery对象之间是可以相互转换的。 因为原生js比jQuery更大,原生的一些属性和方法jQuery没有给我们封装要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 DOM对象转换为jQuery对象: $(DOM对象) 1$('div') jQuery对象转换为DOM对象(两种方式) 12$('div')[index] // index是索引号$('div').get(index) // index是索引号 jQuery选择器 原生JS获取元素方式很多,很杂,而且兼容性情况不一致,因此jQuery给我们做了封装,使获取元素统标准。 1$(\"选择器\") // 里面选择器直接写CSS选择器即可，但是要加引号 基本选择器（跟css的选择器用法一模一样） 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 全选选择器 $(“*”); 匹配所有元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 获取多个元素 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 层级选择器（跟css的选择器用法一模一样） 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 jQuery设置样式1$('div').css('属性','值') 隐式迭代(重要) 遍历内部DOM元素(伪数组形式存储)的过程就叫做隐式迭代。 简单理解:给匹配到的所有元素进行循环遍历,执行相应的方法,而不用我们再进行循环,简化我们的操作,方便我们调用。 jQuery筛选选择器(这类选择器都带冒号) 名称 用法 描述 :first $(“li:first”) 获取第一个li元素 :last $(“li:last”) 获取最后一个li元素 :eq（index） $(“li:eq(2)”) 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(“li:odd”) 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”) 获取到的li元素中，选择索引号为偶数的元素 jQuery筛选方法(重点)(筛选方法是方法) 名称 用法 描述 parent() $(“#first”).parent(); 查找父亲 parents(selector) $(“#first”).parents(); 找到所有的父亲，可以返回指定的元素 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，子类选择器 find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 hasClass(class) $(‘div’).hasClass(‘protected’) 检查当前元素是否有特定的类，有返回true eq(index) $(“li”).eq(2); 相当于$(“li:eq(2)”),index从0开始 重点： parent() children(selector) find(selector) siblings(selector) eq(index) jQuery样式操作操作CSS方法 jQuery可以使用CSS方法来修改简单元素样式;也可以操作类,修改多个样式。 1.参数只写属性名,则是返回属性值 1$(this).css(\"color\"); 2.参数是属性名,属性值,逗号分隔,是设置-组样式,属性必须加引号,值如果是数字可以不用跟单位和引号 1$(this).css(\"color\", \"red\"); 3.参数可以是对象形式,方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号, 1$(this).css({\"color\":\"white\",\"font-size\":\"20px\"); 设置类样式方法 作用等同于以前的classList ,可以操作类样式,注意操作类里面的参数不要加点。 1.添加类 1$(\"div\").addClass(\"current\"); 2.移除类 1$(\"div\").removeClass(\"current\"); 3.切换类 1$(\"div\").toggleClass(\"current\"); 类操作与className区别 原生JS中className会覆盖元素原先里面的类名。 jQuery里面类操作只是对指定类进行操作,不影响原先的类名。 jQuery效果显示隐藏效果 1.隐藏语法规范 1hide([speed],[easing],[fn]]) 2.隐藏参数 (1)参数都可以省略,无动画直接显示。(2) speed :三种预定速度之一 的字符串( “slow” ，”normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。(3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”Ilinear” 。(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。 滑动效果 1.滑动效果语法规范 123456// 下滑slideDown([speed],[easing],[fn]])// 上滑slideUp([speed],[easing],[fn]])// 切换slideToggle([speed],[easing],[fn]]) 2.滑动效果参数(1)参数都可以省略。(2) speed:三种预定速度之一 的字符串( “slow”，”normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。(3) easing:(Optional)用来指定切换效果,默认是”swing” ,可用参数”linear” 。(4) fn:回调函数,在动画完成时执行的函数,每个元素执行次。 动画队列及其停止排队方法 1.动画或效果队列 动画或者效果一旦触发就会执行 ,如果多次触发,就造成多个动画或者效果排队执行。 2.停止排队 1stop() (1) stop()方法用于停止动画或效果。 (2)注意: stop()写到动画或者效果的前面，相当于停止结束上一次的动画。 淡入淡出效果 1.淡入淡出语法规范 12345678// 淡入fadeIn([speed],[easing],[fn]])// 淡出fadeOut([speed],[easing],[fn]])// 切换fadeToggle([speed],[easing],[fn]])// 设置透明度 speed 和 opacity(0~1) 必须写fadeTo(speed,opacity,[easing],[fn]]) 2.淡入淡出效果参数(1)参数都可以省略。(2) speed:三种预定速度之一 的字符串( “slow”，”normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。(3) easing:(Optional)用来指定切换效果,默认是”swing” ,可用参数”linear” 。(4) fn:回调函数,在动画完成时执行的函数,每个元素执行次。 自定义动画animate 1.语法 1animate (params, [speed],[easing],[fn]) 2.参数(1) params:想要更改的样式属性,以对象形式传递,必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法borderLeft。其余参数都可以省略。(2) speed: 三种预定速度之一的字符串( “slow”，”normal” , or “fast” )或表示动画时长的毫秒数值(如 :1000)。(3) easing : (Optional)用来指定切换效果,默认是”swing” , 可用参数”Ilinear” 。(4) fn:回调函数,在动画完成时执行的函数, 每个元素执行次。 jQuery属性操作设置或获取元素固有属性值prop() 所谓元素固有属性就是元素本身自带的属性,比如&lt; a &gt;元素里面的href , 比如&lt; input &gt;元素里的type。 1.获取属性语法 1prop(\"属性\") 2.设置属性语法 1prop(\"属性\", \"属性值\") 设置或获取元素自定义属性值attr() 用户自己给元素添加的属性,我们称为自定义属性。比如给div添加index=“1”。 1.获取属性语法 1attr(\"属性\") // 类似原生getAttribute() 2.设置属性语法 1attr(\"属性\",\"属性值\") // 类似原生setAttribute() 改方法也可以获取H5自定义属性 数据缓存data() data(方法可以在指定的元素上存取数据,并不会修改DOM元素结构。- 旦页面刷新,之前存放的数据都将被移除。 1.附加数据语法 1data(\"name\",\"value\") // 向被选元素附加数据 2.获取数据语法 1date(\"name\") // 向被选元素获取数据 同时,还可以读取HTML5自定义属性data-index , 得到的是数字型 获取data-index h5自定义属性 不用写data- 返回的是数字型 jQuery内容文本值 主要针对元素的内容还有表单的值操作。 1.普通元素内容htmI() (相当于原生inner HTML) 12html() // 获取元素的内容html(\"内容\") // 设置元素的内容 2.普通元素文本内容text() (相当与原生 innerText) 12text() // 获取元素的文本内容text(\"文本内容\") // 设置元素的文本内容 主要针对元素的内容还有表单的值操作。 3.表单的值val() (相当于原生value) 1val() // 获取设置表单值 jQuery元素操作 主要是遍历、创建、添加、删除元素操作。 遍历元素 jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一元素做不同操作,就需要用到遍历。 语法1 :1$(\"div\").each(function(index, domEle){ xxx;}) 1.each(方法遍历匹配的每一个元素。 主要用DOM处理。each每一 个 2.里面的回调函数有2个参数: index 是每个元素的索引号; demEle是每个DOM元素对象,不是jquery对象 3.所以要想使用jquery方法,需要给这个dom元素转换为jquery对象$(domEle) 语法2 :1$.each(object,function (index, element) { xxx;}) 1.$.each(方法可用于遍历任何对象。主要用于数据处理,比如数组,对象2.里面的函数有2个参数: index 是每个元素的索引号; element遍历内容 创建元素 语法: 1$(\"&lt;li&gt;&lt;/li&gt;\"); 动态的创建了一一个&lt; li &gt; 添加元素 1.内部添加 把内容放入匹配元素内部最后面,类似原生appendChild。 12element.append(\"内容\") // 把内容放入目标元素后面element.prepend(\"内容\") // 把内容放入目标元素前面 2.外部添加 12element.after(\"内容\") // 把内容放入目标元素后面element.before(\"内容\") // 把内容放入目标元素前面 删除元素 语法: 123element.remove() // 删除匹配的元素(本身)element.empty() // 删除匹配的元素集合中所有的子节点element.htm(\"\") // 清空匹配的元素内容 jQuery事件注册单个事件注册 语法: 12element.事件(function(){})$(\"div\").click(function(){事件处理程序}) 其他事件和原生基本一致。比如mouseover、mouseout、 blur、 focus、 change、 keydown、 keyup、 resize、 scroll等 jQuery事件处理事件处理on()绑定事件 on()方法在匹配元素上绑定一个或多个事件的事件处理函数 语法: 1element.on(events,[selector], fn) events:-个或多个用空格分隔的事件类型,如”lick’或”keydown”。 selector:元素的子元素选择器。 fn:回调函数即绑定在元素身上的侦听函数。 on()方法优势1 : 可以绑定多个事件,多个处理事件处理程序。 12345$(\"div\").on({ mouseover:function(){}, mouseout:function(){}, click:function(){}}); 如果事件处理程序相同 123$(\"div\").on(\"mouseover mouseout\", function() { $(this).toggleClass (\"current\");}); on()方法优势2 : 可以事件委派操作。事件委派的定义就是,把原来加给子元素身上的事件绑定在父元素身上,就是把事件委派给父元素。 123$('ul').on('click','li', function() { alert('hello world!');}); 在此之前有bind(), live() delegate(等方法来处理事件绑定或者事件委派,最新版本的请用on替代他们。 on0方法优势3 : 动态创建的元素, click()没有办法绑定事件，on() 可以给动态生成的元素绑定事件 事件处理off()解绑事件 off()方法可以移除通过on0方法添加的事件处理程序。 123$(\"p\").off() // 解绑p元素所有事件处理程序$(\"p\").off(\"click\") // 解绑p元素上面的点击事件后面的foo是侦听函数名$(\"ul\").off (\"click\", \"li\"); // 解绑事件委托 如果有的事件只想触发一次，可以使用one()来绑定事件。 1$(\"p\").one(\"click\") // 只能触发点击事件一次 自动触发事件trigger() 有些事件希望自动触发比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件,不必鼠标点击触发。 123456789101112131415161718element.click() // 第一种简写形式element.trigger (\"type\") //第二种自动触发模式$(\"p\").on(\"click\", function () { alert(\"hi~\");});$(\"p\").trigger (\"click\"); //此时自动触发点击事件,不需要鼠标点击element.triggerHandler(\"type\") // 第三种自动触发模式// 3.元素. triggerHandler(\"事件\") 就是不会触发元素的默认行为// 获取文本框焦点案例，光标闪烁是获取文本框的默认事件$(\"input\").on(\"focus\", function() { $(this).val(\"你好吗\");});// $(\"input\").trigger(\"focus\")；// 会触发事件 光标会闪烁$(\"input\").triggerHandler(\"focus\");// 会触发事件 光标不会闪烁 jQuery事件对象 事件被触发,就会有事件对象的产生。 1element.on(events,[selector],function (event) { }) 阻止默认行为: event.preventDefault() 或者 return false 阻止冒泡: event.stopPropagation() jQuery对象拷贝 如果想要把某个对象拷贝(合并)给另外-一个对象使用,此时可以使用$. extend()方法语法: 1$.extend ([deep], target, object1, [objectN]) deep:如果设为true为深拷贝，默认为false浅拷贝 target:要拷贝的目标对象 object1:待拷贝到第一个对象的对象。 objectN:待拷贝到第N个对象的对象。 浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象,修改目标对象会影响被拷贝对象。 深拷贝,前面加true，完全克隆(拷贝的对象，而不是地址) ,修改目标对象不会影响被拷贝对象。 jQuery多库共存 问题概述: jQuery使用$作为标示符,随着jQuery的流行，其他js库也会用这$作为标识符,这样一起使用会引起冲突。 客观需求: 需要一个解决方案,让jQuery和其他的js库不存在冲突,可以同时存在,这就叫做多库共存。 jQuery解决方案: 1.把里面的$符号统-改为jQuery。比如jQuery(“div”)2.jQuery变量规定新的名称: $.noConflict() var xx = $.noConflict(); jQuery插件 jQuery功能比较有限,想要更复杂的特效效果,可以借助于jQuery插件完成。 注意:这些插件也是依赖于jQuery来完成的,所以必须要先引入jQuery文件,因此也称为jQuery插件。 jQuery插件常用的网站: 1.jQuery插件库http://www.jq22.com/ 2.jQuery之家http://www.htmleaf.com/ jQuery插件使用步骤: 1.引入相关文件。( jQuery文件和插件文件) 2.复制相关html、Css、 js (调用插件)。 jQuery插件演示: 1.瀑布流 2.图片懒加载(图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载)当我们页面滑动到可视区域,再显示图片。 我们使用jquery插件库EasyLazyload。 注意,此时的js引入文件和js调用必须写到DOM元素(图片)最后面 3.全屏滚动( fullpage.js ) gitHub : https://github.com/alvarotigo/fullPage.jis 中文翻译网站: http://www.dowebok.com/demo/2014/77/ bootstrap JS插件: bootstrap框架也是依赖于jQuery开发的,因此里面的js插件使用,也必须引入jQuery文件。 jQuery尺寸、位置操作jQuery 尺寸 语法 用法 width()/height() 取得匹配元素宽度和高度值只算width / height innerWidth()/innerHieght) 取得匹配元素宽度和高度值包含padding outerWidth() /outerHeight() 取得匹配元素宽度和高度值包含padding、border outerWidth(true) / outerHeight(true) 取得匹配元素宽度和高度值包含padding、borde、 margin 以上参数为空,则是获取相应值,返回的是数字型。 如果参数为数字,则是修改相应值。 参数可以不必写单位。 jQuery位置位置主要有三个: offset()、position()、 scrollTop()/scrollLeft() offset()设置或获取元素偏移①offset() 方法设置或返回被选元素相对于文档的偏移坐标,跟父级没有关系。 position()获取元素偏移①position()方法用于返回被选元素相对于带有定位的父级偏移坐标,如果父级都没有定位,则以文档为准。 scrollTop0/scrollLeft0设置或获取元素被卷去的头部和左侧①scrollTop0 方法设置或返回被选元素被卷去的头部。 案例:带有动画的返回顶部 ①核心原理:使用animate动画返回顶部。②animate动画函数里面有个scrolITop属性,可以设置位置③但是是元素做动画,因此$(“body,html”).animate({scrollTop: 0})","link":"/2019/12/31/jQuery%E7%AC%94%E8%AE%B0/"},{"title":"Vue路线规划","text":"扎实的HTML/CSS/JS基础(自学)HTML常用标签CSS基础语法Scoped CSSJS基础语法new this ES6语法Object.defineProperty class 设计模式(看vue文档)MVC模式eventbus发布订阅mixin混入prototype原型extends继承依赖注入Vue API(写博客)组件data props methods watch computed template render 钩子beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 模板语法条件：v-if/v-else/v-else-if 循环：v-for 事件：v-on/v-once 属性：v-bind 特殊：v-model 其他：v-text/v-html/v-show/v-pre/v-cloak 过渡动画transition transition-group Webpack配置(说出作用，如何配置)vue-loader @vue/cli sass-loader/less-loader/stylus-loader babel-loader ts-loader eslint Vue全家桶(重要性递减)Vuexstate getter mutation action module Vue Routerhash模式 history模式 守卫 懒加载 Axios拦截器 RESTFul Jext/Mocha单元测试 mock/stub PWAservice worker HTTPS UI框架(了解一两个)ElementAnt Design Vueiviewcube-uiVant到这将成为vue快速开发者 Vue 3.0TypeScriptReact HooksProxy APIReactive 风格函数式编程高级(涉及数据结构和算法)虚拟DOMDiff算法模板编译","link":"/2020/01/05/vue%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/"},{"title":"使用hexo搭建博客并上传Github","text":"安装环境 安装git 安装node.js 运行cmd进行安装Hexo npm install -g hexo 使用git bash 创建hexo目录并初始化 $mkdir hexo $cd hexo $hexo init 然后就可以生成网站，启动服务了： $hexo clean $hexo generate $hexo server 在流浪器输入:http://localhost:4000/ _config.yml文件： deploy: type: git repository: https://github.com/WeDox/WeDoX.github.io.git branch: master $hexo clean $hexo generate $ npm install hexo-deployer-git –save （如果没有这句，执行下面的语句会出现:ERROR Deployer not found: git） $ hexo deploy //提交到github，输入https://wedox.github.io/即可 创建一篇新博客： $ hexo new “我是中国人” 然后到hexo\\source_posts\\我是中国人.md使用Markdown语言进行更新，如下 -– title: My Fist Post with hexo date: 2016-09-25 20:03:25 tags: -– 这是我的第一条博客 我是hexo的链接! ## 第一个标题 ### 我是子标题 $ hexo new “这一句的背景是一条黑线条” ## 我是第二个标题 More info: Writing 重新生成，然后提交到github $hexo clean $hexo generate $ hexo deploy 作者：jdallen链接：https://www.jianshu.com/p/40e7c10065c9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2019/12/27/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0Github/"},{"title":"前端学习线路","text":"HTML5CSS3JavaScriptjquery ajaxnodevue小程序react","link":"/2019/12/27/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%BA%BF%E8%B7%AF/"},{"title":"毕业设计三级提纲","text":"（ 仅供学习参考 ❗） 题目：基于vue &amp; element ui电商后台管理网站设计与实现第一章 绪论.1.1课题研究的背景与意义1.1.1研究的背景和意义 1.1.2网站目的 1.2项目概述1.1 电商项目基本业务概述 1.2 电商后台管理系统的功能 1.3 电商后台管理系统的开发模式 1.3网站开发技术与环境1.2.1 技术栈 1.2.2 开发工具和运行环境 第二章 需求分析2.1 总体需求2.1.1 功能需求 2.1.2 性能需求 第三章 项目开发工具及技术简介3.1 前端开发环境及工具3.1.1 node 3.1.2 vue-cli脚手架 3.1.3 vs code 3.2 Vue.js 开发相关技术3.2.1 vue.2.x 3.2.2 vue-router 3.2.3 axios 3.2.4 vue-cli 3.3 组件库UI3.3. element-ui 第四章 前端布局分析与设计4.1 网站结构布局4.1.1 网站登录页面 4.1.2 网站前台页面设计 4.1.3 其余子页面 4.2 前端UI设计4.2.1模块分布 4.2.2 颜色配置 第五章 主要功能的实现5.1登录概述… 5.2用户管理… 5.3权限管理… 5.4商品管理… 5.5订单管理…第六章项目优化并上线6.1项目优化策略…6.2项目上线… 第七章总结…","link":"/2020/01/04/%E5%9F%BA%E4%BA%8Evue&elementui%E7%9A%84%E6%AF%95%E8%AE%BE/"},{"title":"前端常见跨域解决方案","text":"什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1231.) 资源跳转： A链接、重定向、表单提交2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： 1231.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送 常见跨域场景1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 一、 通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现： 12345678910111213&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); }&lt;/script&gt; 服务端返回如下（返回时即执行全局函数）： 1handleCallback({\"status\": true, \"user\": \"admin\"}) 2.）jquery ajax： 1234567$.ajax({ url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"handleCallback\", // 自定义回调函数名 data: {}}); 3.）vue.js： 123456this.$http.jsonp('http://www.domain2.com:8080/login', { params: {}, jsonp: 'handleCallback'}).then((res) =&gt; { console.log(res); }) 后端node.js代码示例： 1234567891011121314151617var querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) { var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();});server.listen('8080');console.log('Server is running at port 8080...'); jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt; 2.）子窗口：(http://child.domain.com/b.html) 12345&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + '#user=admin'; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert('data from c.html ---&gt; ' + res); }&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 123456789&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; };&lt;/script&gt; 3.）c.html：(http://www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); };&lt;/script&gt; 四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314151617181920212223242526272829303132333435var proxy = function(url, callback) { var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); }};// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data){ alert(data);}); 2.）proxy.html：(http://www.domain1.com/proxy….)中间代理页，与a.html同域，内容为空即可。 3.）b.html：(http://www.domain2.com/b.html) 123&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from domain2 ---&gt; ' + e.data); }, false);&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); } }, false);&lt;/script&gt; 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax 12// 前端设置是否带cookiexhr.withCredentials = true; 示例代码： 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); }}; 2.）jQuery ajax 12345678$.ajax({ ... xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...}); 3.）vue框架 a.) axios设置： 1axios.defaults.withCredentials = true b.) vue-resource设置： 1Vue.http.options.credentials = true 2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台： 12345678910111213/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Requested-With&quot;); 2.）Nodejs后台示例： 12345678910111213141516171819202122232425262728293031323334var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) { var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener('end', function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie }); res.write(JSON.stringify(postData)); res.end(); });});server.listen('8080');console.log('Server is running at port 8080...'); 七、 nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / { add_header Access-Control-Allow-Origin *;} 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： 123456789101112131415#proxy服务器server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; }} 1.) 前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 2.) Nodejs后台示例： 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) { var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, { 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 }); res.write(JSON.stringify(params)); res.end();});server.listen('8080');console.log('Server is running at port 8080...'); 八、 Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send(); 2.）中间件服务器： 123456789101112131415161718192021var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改}));app.listen(3000);console.log('Proxy server is listen at port 3000...'); 3.）Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置： 12345678910111213141516module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 }], noInfo: true }} 九、 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码： 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---&gt; ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); });});document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value);};&lt;/script&gt; 2.）Nodejs socket后台： 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) { res.writeHead(200, { 'Content-type': 'text/html' }); res.end();});server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); });}); 转载https://segmentfault.com/a/1190000011145364)","link":"/2019/12/20/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E5%85%A8%EF%BC%89/"},{"title":"学习日记","text":"11月30日第一次使用typora写日记 创建了个人网站 http://jinyang7.web3v.vip/ 网站简历素材学习 完善简历个人技能 项目经验没写 明天看jQuery 完善简历 12月1日完成的简历，投了宙源科技 准备最近可能的面试 装修个人网站 12月2日复习项目经历rem+flex vue 复习js 完成了music优化 12月3日vue学习p368 复习了axios 12月4日学习了 router webpack 复习了vue-cli脚手架创建 了解了vuex 12月5日vue学习视频p374完成了登录功能并上传码云 学习了git基本用法 电商后台管理系统完成home 的header vue视频p379 https://www.bilibili.com/video/av62487508复习原型 12月6日复习了原型 原型链 解析构造 完成了aside侧边栏菜单获取渲染数据p380 12月7日电商后台管理系统p386https://www.bilibili.com/video/av50680998?p=386 复习vue生命周期函数 完成侧边栏数据获取p390https://www.bilibili.com/video/av50680998?p=390 12月8日作用域插槽 123&lt;templata slot-scope=\"scope\"&gt; // scope.row 中包含当前行中的所有数据 {{scope.row}} 电商后台管理系统p399https://www.bilibili.com/video/av50680998?p=399 12月9日视频p409https://www.bilibili.com/video/av50680998?p=409 完成了添加用户，修改用户，表单验证，预验证 12月10日完成用户列表功能的开发（分支user 合并到master） 创建新分支rights（权限） 看到P430分配权限 做到p422 expand展开数据渲染 完成Right,Roles数据渲染 （重复的功能）Roles中添加角色，编辑，删除功能明天实现 12月11日上午完成了Roles的重复功能 完成展开数据渲染 样式没写 视频P434 整理学习视频https://pan.baidu.com/s/1YvqbO1mnnXzvALQRbdmTfw 12月12日完成了权限功能的开发p440 推送到rights分支，合并到master主分支 12月13日创建子分支goods_cate goods Cate.vue 使用了vue-table-with-tree-grid插件进行表格渲染 视频453 12月14日 管理后台系统BUG：点击编辑按钮 清空可以为空的数据（roles角色描述） 无法保存 ​ BUG: 重新获取数据（this.getCateList()）时，展开项会关闭 完成了分类功能的开发，推送到goods_cate分支，合并到master主分支 视频457 12月15日创建goods_params分支 了解计算属性computed 监听器watch P235 p468 获取的data 不需要分情况 tableData接收的数据 请求参数是动态 传过来的data就是动态数据 反之静态 P470 12月16日完成了分类参数的开发p485 推送到goods_params分支，合并到master主分支 12月17日GitHub创建Learning-diary.github.io vue-shop 同步到GitHub P505 12月18日 bug商品列表和商品分类编辑按钮无法预验证 商品列表编辑提交未实现 完成商品功能开发 推送到goods_list分支，合并到master主分支 视频521 12月19日了解vueP743https://www.bilibili.com/video/av74867960?p=746 P529完成订单功能的开发 推送到order分支，合并到master主分支 p535完成了报表功能的开发 推送到report分支，合并到master主分支 基本使用Echarts图表库 p536进入项目优化 12月20日p536项目优化 完成项目推送到云端 ！复习 p550项目上线 12月21日将桌面改成E盘E:\\Users\\Administrator\\Desktop 重新搭建node环境 将电商后台项目打包部署到个人网站http://jinyang7.web3v.vip/ bug打包的项目渲染有问题 12月22日解决了项目打包的项目渲染有问题：引入csn版本有问题 项目个人logo优化 通过hexo搭建个人博客 12月23日在腾讯云购买了域名goldsheep.club（1元/年）需要解析需要备案 48小时后 三丰云免费空间需要购买域名 放弃 使用liulongbing的后台api接口，完成电商后台项目 继续学习vuex https://www.bilibili.com/video/av74867960?p=757 视频757 创建并初始化vue_todos项目 12月24日搭建hexo博客，使用Icarus主题 上传文件 视频p764 todos项目完成了添加事项，删除事项，剩余条数 $hexo clean $hexo generate 12月25日了解vuepress搭建 完成todes项目推送到GitHub 管理后台系统BUG：修改商品接口有问题 Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。 12月26日学习Ajax https://www.bilibili.com/video/av75465709?p=23 P23 12月27日学习AjaxP50 学完学jQuery 12月28日优化icarus博客 Ajax jQuery todos等jQuery学完在看P52 jQueryP871开始947结束 P898https://www.bilibili.com/video/av74823132?p=898 12月29日优化icarus博客 jQuery P918 12月30日jQuery P940 明天用jQuery完成todolist项目 12月31日完成todolist上传至GitHub jQuery结束 整理jQuery笔记 2020年1月1日 新年快乐！整理jQuery笔记 https://blog.csdn.net/wuyxinu/article/details/103669718 https://www.bilibili.com/video/av74823132?p=906 1月5日前交毕设提纲 1月2日完成jQuery笔记上传博客 1月5日前交毕设提纲 看Ajax jQuery todos https://www.bilibili.com/video/av75465709?p=53 完成三级联动 1月3日看完Ajax 整理Ajax笔记 1月5日前交毕设提纲 vuehttps://www.bilibili.com/video/av62907122?from=search&amp;seid=231858805748132240 1月4日 方应杭vue学习路线整理https://www.bilibili.com/video/av62907122?p=1 完成毕设三级提纲 一个GitHub账号只有一个 账号名.github.io 可以通过 GitHub page中Custom domain自定义域名的修改域名 每个项目都有对应一个的GitHub page : 项目settings中GitHub Pages 资源Source修改成master branch 项目的地址 账号名.github.io/仓库名/进行访问 入口文件必须是index.html 若不为得在账号名.github.io/仓库名/加上入口文件 初步判断vuex-todos项目存在跨域问题 1月5日vuex-todos没有错 不存在跨域 请求的地址对应数据存储的地址 上传git版本回退博客 遇坑hexo发布后，github pages的Custom domain配置项被清空是什么原因？ 新建一个名为CNAME(不要指定文件类型)的文件丢在source目录下里面，然后 hexo clean hexo g hexo d,然后就可以了 整理了vue路线明天从头开始 1月6日复习JS 看视频P515-P619，https://www.bilibili.com/video/av74823132?p=619 读文档 明天继续 1月7日js复习视频p696 https://www.bilibili.com/video/av74823132?p=696 vue复习视频 https://www.bilibili.com/video/av82296438","link":"/2019/11/30/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"title":"学习笔记","text":"Git常见操作 git status 查看当前项目中源代码的状态 git add . 全部添加到暂存区 git commit -m &quot;提交信息&quot; 把暂存区所有代码提交到本地仓库中 git branch 查看分支 *当前处于分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换到分支 git merge 分支名 合并分支（合并到本地，云端并没有） git push 把本地分支中最新的代码推送到远程仓库中 默认master主分支 git push -u origin 分支名 第一次推送到此分支的时候使用 分支（login）合并到主分支（master） 1.切换到主分支 git checkout master 2.合并分支 git merge login 3.推送到云端（仓库）git push get和post请求区别 还有哪些http method get和post本质上没有区别，他们都是http的请求方式，基于tcp协议，但因为在不同的浏览器实现，就有了不同。 get请求的数据放在url上，post请求的数据放在http的包体内，所以说post相对get更安全。 get是通过URL提交数据，因此get提交数据根据url长度有关，不同的浏览器不同，一般是2k，而post理论上是没有限制的。 get幂等，post不幂等。 幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他请求方式（http method） head、put、delete、trace、connect、options vue的computed属性和methods区别最大的区别是缓存 计算属性是基于它们的依赖进行缓存的 方法不存在缓存 computed是响应式的，methods并非响应式。 调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。 computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的 初始化数据123456// 字符串string:'',// 数组array:[],// 数字number：0 vue过滤器p237 生命周期p239 render12345new Vue({ render: h =&gt; h(App)}).$mount('#app') render: h =&gt; h(App) 渲染到APP组件 $mount(‘#app’) 挂载到#app上 这是Vue 2.0新增的函数，可以直接给绑定节点渲染一个vue组件，如果在Vue 1.x下，就应该使用 1234new Vue({ el: '#app', components: { App }}); 然后在页面中写入标记： 123&lt;div id=&quot;app&quot;&gt; &lt;app&gt;&lt;/app&gt;&lt;/div&gt; 数组操作trim() 方法用于删除字符串的头尾空格。 trim() 方法不会改变原始字符串。 ES6，Array.find()和findIndex()函数的用法]ES6为Array增加了find()，findIndex函数。 find()函数用来查找目标元素，找到就返回该元素，找不到返回undefined。 findIndex()函数也是查找目标元素，找到就返回元素的位置，找不到就返回-1。 json**JSON.parse()** 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。 **JSON.stringify()** 方法将一个 JavaScript 值（对象或者数组）转换为一个 JSON 字符串。","link":"/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"常见前端面试题","text":"get和post请求区别 还有哪些http methodget和post本质上没有区别，他们都是http的请求方式，基于tcp协议，但因为在不同的浏览器实现，就有了不同。 get请求的数据放在url上，post请求的数据放在http的包体内，所以说post相对get更安全。 get是通过URL提交数据，因此get提交数据根据url长度有关，不同的浏览器不同，一般是2k，而post理论上是没有限制的。 get幂等，post不幂等。 幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。 GET在浏览器回退时是无害的，POST会再次提交请求。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET只接受ASCII字符的参数的数据类型，而POST没有限制 那么，post那么好为什么还用get？get效率高！。 其他请求方式（http method） head、put、delete、trace、connect、options js数据类型undefined 未定义类型 null 空类型 boolean 布尔类型 number 数值型 string 字符串类型 symbol １种复杂数据类型：object —— 对象类型 csscalc, support, media各自的含义及用法？@support主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。 calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-“, “*”, “/“ 运算； @media 查询，你可以针对不同的媒体类型定义不同的样式。 css水平、垂直居中的写法，请至少写出4种？ 这题考查的是css的基础知识是否全面，所以平时一定要注意多积累 水平居中 行内元素: text-align: center 块级元素: margin: 0 auto position:absolute +left:50%+ transform:translateX(-50%) display:flex + justify-content: center 垂直居中 设置line-height 等于height position：absolute +top:50%+ transform:translateY(-50%) display:flex + align-items: center display:table+display:table-cell + vertical-align: middle; 1rem、1em、1vh、1px各自代表的含义？ rem rem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。 em 子元素字体大小的em是相对于父元素字体大小 元素的width/height/padding/margin用em的话是相对于该元素的font-size vw/vh 全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。 px px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 一般电脑的分辨率有{1920*1024}等不同的分辨率 1920*1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素 画一条0.5px的直线？ 考查的是css3的transform 12height: 1px;transform: scale(0.5); 说一下盒模型？ 盒模型是css中重要的基础知识，也是必考的基础知识 盒模型的组成，由里向外content,padding,border,margin. 在IE盒子模型中，width表示content+padding+border这三个部分的宽度 在标准的盒子模型中，width指content部分的宽度 box-sizing的使用 12box-sizing: content-box 是W3C盒子模型box-sizing: border-box 是IE盒子模型 box-sizing的默认属性是content-box 画一个三角形？ 这属于简单的css考查，平时在用组件库的同时，也别忘了原生的css 12345678910 .a{ width: 0; height: 0; border-width: 100px; border-style: solid; border-color: transparent #0099CC transparent transparent; transform: rotate(90deg); /*顺时针旋转90°*/ }&lt;div class=\"a\"&gt;&lt;/div&gt; 清除浮动的几种方式，及原理？ 清除浮动简单，但这题要引出的是BFC，BFC也是必考的基础知识点 ::after / / clear: both 创建父级 BFC(overflow:hidden) 父级设置高度 BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 触发条件: 根元素 position: absolute/fixed display: inline-block / table float 元素 ovevflow !== visible 规则: 属于同一个 BFC 的两个相邻 Box 垂直排列 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 文字层不会被浮动层覆盖，环绕于周围 html说一下标签的用法label标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验 遍历A节点的父节点下的所有子节点 这题考查原生的js操作dom,属于非常简单的基础题，但长时间使用mvvm框架，可能会忘记 1234&lt;script&gt; var b=document.getElementById(\"a\").parentNode.children; console.log(b)&lt;/script&gt; js用js递归的方式写1到100求和？ 递归我们经常用到，vue在实现双向绑定进行数据检验的时候用的也是递归，但要我们面试的时候手写一个递归，如果对递归的概念理解不透彻，可能还是会有一些问题。 123456789function add(num1,num2){ var num = num1+num2; if(num2+1&gt;100){ return num; }else{ return add(num,num2+1) } }var sum =add(1,2); 页面渲染html的过程？ 不需要死记硬背，理解整个过程即可 浏览器渲染页面的一般过程： 1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。 2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。 3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。 DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。 4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。 以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。 说一下CORS？CORS是一种新标准，支持同源通信，也支持跨域通信。fetch是实现CORS通信的 如何中断ajax请求？一种是设置超时时间让ajax自动断开，另一种是手动停止ajax请求，其核心是调用XML对象的abort方法，ajax.abort() 说一下事件代理？事件委托是指将事件绑定到目标元素的父元素上，利用冒泡机制触发该事件 123456ulEl.addEventListener('click', function(e){ var target = event.target || event.srcElement; if(!!target &amp;&amp; target.nodeName.toUpperCase() === \"LI\"){ console.log(target.innerHTML); }}, false); target、currentTarget的区别？currentTarget当前所绑定事件的元素 target当前被点击的元素 说一下宏任务和微任务？ 宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。 微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick等等）。 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。 说一下继承的几种方式及优缺点？ 说比较经典的几种继承方式并比较优缺点就可以了 借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上 原型继承，将子对象的prototype指向父对象的一个实例 组合继承 原型链继承的缺点 字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 说一下闭包？闭包的实质是因为函数嵌套而形成的作用域链 闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包 export和export default的区别？使用上的不同 12345export default xxximport xxx from './'export xxximport {xxx} from './' 说一下自己常用的es6的功能？ 此题是一道开放题，可以自由回答。但要注意像let这种简单的用法就别说了，说一些经常用到并有一定高度的新功能 像module、class、promise等，尽量讲的详细一点。 什么是会话cookie,什么是持久cookie?cookie是服务器返回的，指定了expire time（有效期）的是持久cookie,没有指定的是会话cookie 数组去重？ 此题看着简单，但要想面试官给你高分还是有难度的。至少也要写出几种方法 js 1234567891011121314151617181920212223242526272829303132333435var arr=['12','32','89','12','12','78','12','32']; // 最简单数组去重法 function unique1(array){ var n = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++){ //遍历当前数组 if (n.indexOf(array[i]) == -1) n.push(array[i]); } return n; } arr=unique1(arr); // 速度最快， 占空间最多（空间换时间） function unique2(array){ var n = {}, r = [], type; for (var i = 0; i &lt; array.length; i++) { type = typeof array[i]; if (!n[array[i]]) { n[array[i]] = [type]; r.push(array[i]); } else if (n[array[i]].indexOf(type) &lt; 0) { n[array[i]].push(type); r.push(array[i]); } } return r; } //数组下标判断法 function unique3(array){ var n = [array[0]]; //结果数组 for(var i = 1; i &lt; array.length; i++) { //从第二项开始遍历 if (array.indexOf(array[i]) == i) n.push(array[i]); } return n; } es6 123456es6方法数组去重arr=[...new Set(arr)];es6方法数组去重，第二种方法function dedupe(array) { return Array.from(new Set(array)); //Array.from()能把set结构转换为数组} get、post的区别 此题比较简单，但一定要回答的全面 1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内 2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制 3.get后退不会有影响，post后退会重新进行提交 4.get请求可以被缓存，post不可以被缓存 5.get请求只URL编码，post支持多种编码方式 6.get请求的记录会留在历史记录中，post请求不会留在历史记录 7.get只支持ASCII字符，post没有字符类型限制 你所知道的http的响应码及含义？ 此题有过开发经验的都知道几个，但还是那句话，一定要回答的详细且全面。 1xx(临时响应) 100: 请求者应当继续提出请求。 101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。 2xx(成功) 200：正确的请求返回正确的结果 201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。 202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。 3xx(已重定向) 300：请求成功，但结果有多种选择。 301：请求成功，但是资源被永久转移。 303：使用 GET 来访问新的地址来获取资源。 304：请求的资源并没有被修改过 4xx(请求错误) 400：请求出现错误，比如请求头不对等。 401：没有提供认证信息。请求的时候没有带上 Token 等。 402：为以后需要所保留的状态码。 403：请求的资源不允许访问。就是说没有权限。 404：请求的内容不存在。 5xx(服务器错误) 500：服务器错误。 501：请求还没有被实现。","link":"/2019/11/30/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"毕设","slug":"毕设","link":"/tags/%E6%AF%95%E8%AE%BE/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"学习日记","slug":"学习日记","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"前端面试题","slug":"前端面试题","link":"/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"categories":[{"name":"Git操作","slug":"Git操作","link":"/categories/Git%E6%93%8D%E4%BD%9C/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"}]}